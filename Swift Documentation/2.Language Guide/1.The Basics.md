# The Basics (기본)

일반적인 종류의 데이터로 작업하고 기본 구문을 작성합니다.

Swift 는 정수에 대한 `Int`, 부동 소수점(floating-point) 값에 대한 `Double`, 부울(Boolean) 값에 대한 `Bool` 그리고 텍스트에 대한 `String` 을 포함하는 많은 기본적인 데이터 타입을 제공합니다.

Swift 는 또한 [콜렉션 타입(Collection Types)](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/4.Collection%20Types.md) 에서 자세히 다룰 `Array`, `Set` 그리고 `Dictionary` 인 3개의 기본 콜렉션 타입을 제공합니다.

#

Swift 는 변수를 식별 가능한 이름으로 값을 저장하고 참조합니다. Swift 는 또한 값을 변경할 수 없는 변수를 광범위하게 사용합니다.

이러한 변수를 상수라고 하며 값을 변경할 필요가 없을 때 코드를 더 안전하고 명확하게 만들기위해 Swift 에서 사용됩니다.

#

익숙한 타입 외에도 Swift 는 튜플(tuple)이라는 고급 타입이 있습니다. 튜플은 값을 그룹화하여 생성하거나 전달할 수 있습니다.

튜플을 사용하여 함수의 여러값을 단일 복합 값으로 반환할 수 있습니다.

#

Swift 는 또한 값이 존재하지 않는 경우를 처리하기 위해 옵셔널(Optional) 타입이 있습니다.

옵셔널은 "값이 있고 x와 같다" 또는 "값이 없다"를 알려줍니다.

#

Swift 는 타입-세이프(type-safe) 언어입니다. 즉, 언어가 코드에서 사용할 수 있는 값의 타입을 명확하게 하는 데 도움이 됩니다.

만약 `String` 을 요구하는 코드에서 실수로 `Int` 로 전달하는 것을 방지할 수 있습니다.

마찬가지로 타입 세이프티(type safety)는 옵셔널이 아닌 `String` 을 요구하는 코드에 옵셔널 `String` 을 실수로 전달하는 것을 방지합니다.
 
타입 세이프티(type safety)는 개발 프로세스에서 가능한 빠르게 에러를 찾고 수정하는데 도움이 됩니다.

<br>

## 상수와 변수 (Constants and Variavles)

상수와 변수는 이름(`maximumNumberOfLoginAttempts` 또는 `welcomeMessage`)과 특정 타입(숫자 `10` 또는 문자열 `Hello`)의 값을 연결합니다.

상수(Constant)의 값은 최초 지정 후 변경이 불가능하지만 변수(Variable)는 다른 값으로 변경이 가능합니다.

<br>

## 상수와 변수 선언 (Declaring Conatants and Variables)

상수와 변수는 사용하기 전에 반드시 선언이 되어야 합니다. `let` 키워드를 사용하여 상수를 선언하고 `var` 키워드를 사용하여 변수를 선언합니다.

다음의 예제는 사용자가 로그인을 시도한 횟수를 추적하기 위해 상수와 변수를 사용하는 방법에 대한 예입니다.

~~~ swift
let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
~~~

이 코드는 아래와 같이 읽을 수 있습니다.

"`maximumNumberOfLoginAttempts` 인 새로운 상수를 선언하고  `10` 이라는 값을 지정합니다.

그리고 `currentLoginAttempt` 인 새로운 변수를 선언하고 초기값을 `0` 으로 지정합니다."

#

이 예제에서는 최대 로그인 시도 횟수는 최대값이 절대 변경되지 않아야 하므로 상수로 선언하였습니다.

현재 로그인 시도 횟수는 로그인 실패시 값을 증가시켜야 하므로 변수로 선언하였습니다.

#

코드에서 저장된 값이 변경되지 않으면 `let` 키워드로 상수로 선언합니다.

변경되는 값을 저장하는 곳에만 변수를 사용합니다.

#

상수 또는 변수로 선언할때, 위의 예제처럼 선언하는 부분에 값을 줄 수 있습니다.

또는 처음 값을 읽기 전에 값의 존재가 보장되면 프로그램에 마지막에 초기화 값을 할당할 수 있습니다.

#

~~~ swift
var environment = "development"
let maximumNumberOfLoginAttempts: Int
// maximumNumberOfLoginAttempts has no value yet.


if environment == "development" {
    maximumNumberOfLoginAttempts = 100
} else {
    maximumNumberOfLoginAttempts = 10
}
// Now maximumNumberOfLoginAttempts has a value, and can be read.
~~~

이 예제에서 로그인 시도 최대횟수는 상수이고 이값은 환경에 따라 달라집니다.

개발 환경에서는 100의 값을 가지고 다른 환경에서는 10을 가집니다.

`if` 구문의 각 조건에서 어떠한 값으로 `maximumNumberOfLoginAttempts` 을 초기화하고, 이 상수는 항상 값이 있음을 보장합니다.

이 방법으로 초기값을 설정할 때, Swift 가 어떻게 코드를 검사하는지 자세한 내용은 [상수선언 (Constant Declaration)]() 을 참고 하세요.

#

여러개의 상수 또는 여러개의 변수를 선언할 때 콤마로 구분하여 한줄로 선언이 가능합니다.

~~~ swift
var x = 0.0, y = 0.0, z = 0.0
~~~

<br>

## 타입 명시 (Type Annotations)

상수 또는 변수를 선언할 때 타입 명시(Type Annotations)를 제공하여 상수나 변수가 저장할 수 있는 값의 종류를 명확히 할 수 있습니다.

타입 명시는 상수 또는 변수 이름 뒤에 콜론과 공백 한칸 뒤에 사용할 타입 이름을 적어 사용합니다.

#

이 예제는 `welcomeMessage` 라는 변수에 `String` 값을 저장할 수 있음을 나타내기 위해 변수에 타입 명시를 제공합니다.

~~~ swift
var welcomeMessage: String
~~~

위 코드에서 선언에 있는 콜론은 "...의 타입은..." 을 의미하므로 아래와 같이 읽을 수 있습니다.

#

"선언한 변수는 `welcomeMessage` 라고 하며 이것의 타입은 `String` 입니다."

"...의 타입은 `String` 입니다." 라는 의미는 "모든 `String` 값을 저장 가능합니다." 라는 의미 입니다.

저장할 수 있는 "어떠한 타입" (또는 "어떠한 종류") 라고 생각하면 됩니다.

#

`welcomeMessage` 변수는 이제 아무런 오류 없이 어떠한 문자열 값을 지정할 수 있습니다.

~~~ swift
welcomeMessage = "Hello"
~~~

같은 타입에 여러개의 연관된 변수를 콤마로 변수 이름을 구분하고, 마지막 변수 이름 뒤에 하나의 타입 명시를 통해 한줄로 선언할 수 있습니다.

~~~ swift
var red, green, blue: Double
~~~

> Note   
> 실제로 타입 명시를 작성해야 하는 경우는 거의 없습니다. 상수 또는 변수를 선언할 때 초기값을 지정하면 Swift 는 [타입 세이프티와 타입 추론(Type Safety and Type Inference)]() 에서
> 설명된 대로 해당 상수 또는 변수에 사용될 타입을 거의 항상 추론할 수 있습니다.
> 위의 `welcomeMessage` 예제에서 초기값을 지정하지 않았으므로 `welcomeMessage` 변수의 타입은 초기값에서 유추되지 않고 타입을 명시 하였습니다.

<br>

## 상수와 변수의 이름 (Naming Constants and Variables)

상수와 변수 이름은 유니코드 (Unicode) 문자를 포함하여 대부분의 문자를 포함할 수 있습니다.

~~~ swift
let π = 3.14159
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"
~~~

상수와 변수 이름은 공백, 수학적 기호, 화살표, 내부에서 사용하는 유니코드 스칼라 값, 또는 선과 박스를 그리는 문자가 포함될 수 없습니다.

이름의 다른 곳에 숫자가 포함될 수는 있지만 숫자로 시작하는 이름은 선언할 수 없습니다.

#

특정 타입의 상수 또는 변수를 선언한 후에 동일한 이름으로 다시 선언하거나 다른 타입의 값을 저장하도록 변경하여 변경하여 선언할 수 없습니다.

상수를 변수로 바꾸거나 변수를 상수로 바꿀 수도 없습니다.

> Note   
> Swift 키워드와 동일한 이름의 상수 또는 변수를 제공해야 한다면 이름을 백틱(`)으로 묶어야 합니다.  
> 그러나 선택의 여지가 전혀 없는 경우가 아니면 키워드를 이름으로 사용하지 말아야 합니다.

#

기존 변수의 값을 동일한 타입의 다른 값으로 변경할 수 있습니다.

아래의 예제에서는 `friendlyWelcome` 값이 `"Hello!"` 에서 `"Bonjour!"` 로 변경됩니다.

~~~ swift
var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome is now "Bonjour!"
~~~

#

변수와 달리 상수값은 지정된 이후에는 변경할 수 없습니다.

값의 변경을 시도하면 코드가 컴파일 될 때 오류가 발생합니다.

~~~ swift
let languageName = "Swift"
languageName = "Swift++"
// This is a compile-time error: languageName cannot be changed.
~~~

<br>

## 상수와 변수 출력 (Printing Constants and Variables)

`print(_:separator:terminator:)` 함수를 사용하여 상수 또는 변수의 현재 값을 출력할 수 있습니다.

~~~ swift
print(friendlyWelcome)
// Prints "Bonjour!"
~~~

#

`print(_:separator:terminator:)` 함수는 하나 또는 그 이상의 값을 출력하는 전역 함수 입니다.

예를 들어 Xcode 에서 `print(_:separator:terminator:)` 함수는 Xcode "콘솔 (console)" 창에 결과를 출력합니다.

`separator` 와 `terminator` 파라미터는 기본 값을 가지고 있으므로 함수를 호출할 때 생략할 수 있습니다.

기본적으로 이 함수는 줄바꿈을 출력하고 종료됩니다.

줄바꿈 없이 값을 출력하려면 `print(someValue, terminator: "")` 와 같이 `terminator` 에 빈 문자열을 넘겨주면 됩니다.

기본값이 있는 파라미터에 대한 자세한 내용은 [파라미터 기본 값 (Default Parameter Values)]() 을 참고 하십시오.

#

Swift 는 긴 문자열에 상수 또는 변수의 이름을 포함하여 Swift 가 상수 또는 변수의 현재 값으로 바꾸도록 하기 위해 문자열 삽입 (String interpolation) 을 사용합니다.

이름을 소괄호로 감싸고 소괄호 전에 백슬래시를 추가해야 합니다.

~~~ swift
print("The current value of friendlyWelcome is \(friendlyWelcome)")
// Prints "The current value of friendlyWelcome is Bonjour!"
~~~

> Note   
> 문자열 삽입에 사용할 수 있는 모든 옵션은 [문자열 삽입 (String interpolation)]() 에 자세히 설명되어 있습니다.

<br>

## 주석 (Comments)

코드에서 설명 또는 기록을 위해 실행되지 않는 문자를 추가할 땐 주석 (Comments) 을 사용합니다.

코드가 컴파일될 때 Swift 컴파일러는 주석을 무시됩니다.

Swift 의 주석은 C 의 주석과 매우 유사합니다.

한줄 주석은 두개의 슬래시 (`//`) 로 시작합니다.

~~~ swift
// This is a comment.
~~~

#

여러줄의 주석은 슬래시와 별표 (`/*`) 로 시작하고 별표와 슬래시 (`*/`) 로 끝납니다.

~~~ swift
/* This is also a comment
but is written over multiple lines. */
~~~

#

C 의 여러줄 주석과 다르게 Swift 의 여러줄 주석은 다른 여러줄 주석 안에 중첩될 수 있습니다.

여러줄 주석 블럭을 시작한 다음 첫번째 블럭 내에서 두번째 여러줄 주석을 시작하여 중첩된 주석을 작성합니다.

그런다음 두번째 블럭이 닫히고 첫번째 블럭이 이어집니다.

~~~ swift
/* This is the start of the first multiline comment.
    /* This is the second, nested multiline comment. */
This is the end of the first multiline comment. */
~~~

중첩된 여러줄 주석을 사용하면 코드에 이미 여러줄 주석이 포함되어 있어도 큰 코드 블럭을 빠르고 쉽게 주석 처리할 수 있습니다.

<br>

## 세미콜론 (Semicolons)

다른 많은 언어와 달리 Swift 는 코드의 각 명령문 뒤에 세미콜론 (`;`) 을 작성하는 것은 필수조건이 아닙니다.

물론 원한다면 그렇게 할 수도 있습니다.

그러나 한줄에 여러개의 개별 명령문을 작성하려면 세미콜론은 필수로 작성되어야 합니다.

~~~ swift
let cat = "🐱"; print(cat)
// Prints "🐱"
~~~

<br>

## 정수 (Integers)

정수 (Integers) 는 `42` 와 `-23` 과 같은 분수가 아닌 전체 숫자 입니다.

정수는 부호가 있는 정수 (signed)(양수, 0, 음수) 또는 부호가 없는 정수 (unsinged)(양수, 0) 이 있습니다.

#

Swift 는 8, 16, 32, 64 비트 형태의 부호가 있는 정수와 부호가 없는 정수를 제공합니다.

이러한 정수는 8-bit 부호가 없는 정수는 `UInt8` 그리고 32-bit 부호가 있는 정수는 `Int32` 와 같이 C 와 비슷한 네이밍 규칙을 따릅니다.

Swift 의 모든 타입과 마찬가지로 정수 타입은 대문자로 시작합니다.

<br>

### 정수 범위 (Integer Bounds)

각 정수 타입의 `min` 과 `max` 프로퍼티를 통해 각 정수 타입의 최소값과 최대값에 접근할 수 있습니다.

~~~ swift
let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8
~~~

이러한 프로퍼티의 값은 적절한 크기의 숫자 타입 (위의 예제에서 `UInt8`) 이므로 동일한 타입의 다른 값과 함께 표현식에 사용될 수 있습니다.

<br>

### Int

대부분의 경우 코드에서 사용할 정수의 특정 사이즈를 결정할 필요는 없습니다.

Swift 는 현재 플랫폼의 네이티브 사이즈와 같은 `Int` 인 정수 타입을 제공합니다.

- 32-bit 플랫폼에서 `Int` 는 `Int32` 와 같은 크기를 갖습니다.
- 64-bit 플랫폼에서 `Int` 는 `Int64` 와 같은 크기를 갖습니다.

#

특정 크기의 정수로 작업해야 하는 경우가 아니라면 항상 코드의 정수 값을 사용할 때 `Int` 를 사용하십시오.

이것은 코드 일관성과 상호 운용성에 도움이 됩니다.

32-bit 플랫폼에서도 `Int` 는 `-2,147,483,648` 과 `2,147,483,647` 사이의 값을 저장할 수 있으며 일반적인 사용성에 문제가 없습니다.

<br>

### UInt

Swift 는 또한 현재의 플랫폼의 네이티브 사이즈와 같은 `UInt` 인 정수 타입을 제공합니다.

- 32-bit 플랫폼에서 `UInt` 는 `UInt32` 와 같은 크기를 갖습니다.
- 64-bit 플랫폼에서 `UInt` 는 `UInt64` 와 같은 크기를 갖습니다.

> Note      
> `UInt` 는 플랫폼의 네이티브 사이즈와 같은 크기의 부호없는 정수 타입이 필요한 경우에만 사용하십시오.
> 그렇지 않은 경우에도 저장될 값이 음수가 아니어도 `Int` 가 더 선호됩니다.
> 정수값에 `Int` 를 일관되게 사용하면 코드 상호 운용성이 향상되고, 서로다른 숫자 타입간 변환이 필요하지 않으며,
> [타입 세이프티와 타입 추론 (Type Safety and Type Inference)]() 에 설명된 대로 정수 타입 추론과 일치합니다.

<br>

## 부동 소수점 숫자 (Floating-Point Numbers)

부동 소수점 숫자 (Floating-point numbers) 는 `3.14159`, `0.1`, 및 `-273.15` 와 같이 분수 요소가 있는 숫자입니다.

부동 소수점 타입은 정수 타입보다 훨씬 더 넓은 범위의 값을 나타낼 수 있으며 `Int` 보다 더 크거나 작은 값 저장이 가능합니다.

Swift 는 2개의 부호를 가진 부동 소수점 타입을 제공합니다.

- `Double` 은 64-bit 부동 소수점 숫자를 나타냅니다.
- `Float` 은 32-bit 부동 소수점 숫자를 나타냅니다.

> Note     
> `Double` 은 최소 15자리의 소수점 정확도를 가지고 있는것에 반해 `Float` 은 더 적은 6자리의 정확도를 가집니다.
> 적절하게 사용할 부동 소수점 타입은 코드에서 작업해야하는 값의 특성과 범위에 따라 다릅니다.
> 두 타입이 모두 적합한 상황에서는 `Double` 이 선호 됩니다.

<br>

## 타입 세이프티와 타입 추론 (Type Safety and Type Inference)

Swift 는 타입-세이프 (type-safe) 언어입니다.

타입 세이프 언어는 코드에서 사용할 수 있는 값의 타입을 명확하게 하도록 권장합니다.

코드의 일부에서 `String` 이 필요한 경우 실수로 `Int` 를 전달할 수 없습니다.

#

Swift 는 타입 세이프 언어이기 때문에 코드를 컴파일할 때 타입 검사를 수행하고 일치하지 않는 타입을 에러로 표시합니다.

이를 통해 개발 프로세스에서 가능한 한 빨리 오류를 포착하고 수정할 수 있습니다.

#

타입 검사는 다양한 타입의 값으로 작업할 때 오류를 방지하는데 도움이 됩니다.

그러나 이것이 선언하는 모든 상숭와 변수의 타입을 지정해야 한다는 의미는 아닙니다.

필요한 값의 특정 타입을 지정하지 않으면 Swift 는 타입 추론 (Type Inference) 을 사용하여 적절한 타입을 찾습니다.

타입 추론을 통해 컴파일러는 코드를 컴파일할 때 제공된 값을 검사하여 자동으로 특정 표현식의 타입을 추론할 수 있습니다.

#

타입 추론으로 인해 Swift 에서는 C 나 Objective-C 와 같은 언어보다 훨씬 적은 타입 선언이 요구됩니다. 

상수와 변수는 여전히 명시적으로 타입이 지정되지만 그것들의 타입을 지정하는 작업 중 많은 부분이 자동으로 처리됩니다.

#

타입 추론은 특히 상수 또는 변수에 초기값을 선언할 때 아주 유용합니다.

이는 선언하는 시점에서 상수나 변수에 리터럴 값 (literal value) 또는 리터럴 (literal) 을 할당하여 수행되는 경우가 많습니다.   
(리터럴 값은 아래 예에서 42, 3.14159 와 같이 소스 코드에 직접 표시되는 값입니다.)

#

예를 들어 어떤 타입인지 선언하지 않고 새로운 상수에 42 의 리터럴 값으로 할당하면 Swift 는 정수처럼 보이는 숫자로 초기화 했기 때문에 상수가 `Int` 라고 추론합니다.

~~~ swift
let meaningOfLife = 42
// meaningOfLife is inferred to be of type Int
~~~

#

마찬가지로 부동 소수점 리터럴 값에 대한 타입을 지정하지 않으면 Swift 는 `Double` 이라고 추론합니다.

~~~ swift
let pi = 3.14159
// pi is inferred to be of type Double
~~~

#

Swift 는 부동 소수점 숫자의 타입을 추론할 때 항상 `Float` 보다 `Double` 을 선택하여 추론합니다.

표현식에서 정수와 부동 소수점 리터럴 값을 결합하면 컨텍스트에서는 `Double` 타입으로 추론됩니다.

~~~ swift
let anotherPi = 3 + 0.14159
// anotherPi is also inferred to be of type Double
~~~

`3` 인 리터럴 값에는 명시적인 타입이 없으므로 추가로 부동 소수점 리터럴 값이 존재하는 경우 `Double` 타입이 추론됩니다.

<br>

## 숫자 리터럴 (Numeric Literals)

정수 리터럴은 아래와 같이 작성할 수 있습니다.

- 접두사가 없는 10진수
- `0b` 접두사가 있는 2진수
- `0o` 접두사가 있는 8진수
- `0x` 접두사가 있는 16진수

#

아래의 예에서 모든 정수 리터럴 값은 10진수 `17` 의 값을 가집니다.

~~~ swift
let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation
~~~

#

부동 소수점 리터럴은 10진수 (접두사 없음) 또는 16진수 (접두사 `0x`) 일 수 있습니다.

소수점 양쪽에는 항상 숫자 (또는 16진수) 가 있어야 합니다.

10진수는 대문자 또는 소문자 `e` 로 표시되는 지수를 가질 수도 있습니다.

16진수는 대문자 또는 소문자 `p` 로 표시되는 지수를 가질 수도 있습니다.

#

지수가 `x` 인 10진수는 기본 숫자에 10ˣ 가 곱해집니다.

- `1.25e2` 는 1.25 x 10², 또는 125.0
- `1.25e-2` 는 1.25 x 10⁻², 또는 0.0125

#

지수가 `x` 인 16진수는 기본 숫자에 2ˣ 가 곱해집니다.

- `0xFp2` 는 15 x 2², 또는 60.0
- `0xFp-2` 는 15 x 2⁻², 또는 3.75

#

아래의 예에서 모든 부동 소수점 리터럴은 10진수 `12.1875` 를 가집니다.

~~~ swift
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
~~~

#

숫자 리터럴에는 읽기 쉽게 만드는 추가 포맷을 포함시킬 수 있습니다.

정수와 부동 소수점 모두 추가적으로 0이 채워질 수 있으며 가독성을 높이기 위해 밑줄을 포함할 수 있습니다.

어떤 형식도 리터럴의 기본값에 영향을 주지 않습니다.

~~~ swift
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
~~~

<br>

## 숫자 타입 변환 (Numeric Type Conversion)

음수를 사용하지 않더라도 코드에서 상수와 변수가 정수로 사용이 되면 `Int` 타입을 사용하십시오.

일반적인 상황에서 기본 정수 타입을 사용한다는 것은 정수인 상수와 변수가 코드에서 즉시 상호 운용 가능하고 정수 리터럴 값의 유추된 타입과 일치한다는 것을 의미합니다.

#

외부 소스에서 명시적으로 크기가 지정된 데이터 또는 성능, 메모리 사용, 또는 기타 필요한 최적화 등 특별히 필요한 경우에만 다른 정수 타입을 사용하십시오.

이러한 상황에서 명시적으로 크기가 지정된 타입을 사용하면 실수로 인한 값 초과를 포착하고 사용중인 데이터의 특성을 암시적으로 아는데 도움이 됩니다.

<br>

### 정수 변환 (Integer Conversion)

정수를 저장할 수 있는 상수 또는 변수의 숫자 범위는 각 숫자 타입에 따라 다릅니다.

`Int8` 타입의 상수 또는 변수는 `-128` 과 `127` 사이의 숫자를 저장할 수 있는 반면에 `UInt8` 타입의 상수 또는 변수는 `0` 과 `255` 사이의 숫자를 저장할 수 있습니다.

크기가 지정된 정수 타입의 상수 또는 변수에 크기가 맞지않는 숫자는 컴파일할 때 에러가 발생합니다.

~~~ swift
let cannotBeNegative: UInt8 = -1
// UInt8 can't store negative numbers, and so this will report an error
let tooBig: Int8 = Int8.max + 1
// Int8 can't store a number larger than its maximum value,
// and so this will also report an error
~~~

#

각 숫자 타입은 서로 다른 범위의 값을 저장할 수 있으므로 각 타입별로 숫자 타입 변환을 선택해야 합니다.

이 방식은 숨겨진 변환 에러를 방지하고 코드에서 타입 변환 의도를 명시적으로 만드는데 도움을 줍니다.

#

특정 숫자 타입을 다른 숫자 타입으로 변환하려면 기존 값을 사용하여 원하는 타입의 새 숫자를 초기화 합니다.

아래의 예제에서 상수 `twoThousand` 는 `UInt16` 타입이고 상수 `one` 은 `UInt8` 타입입니다.

두 상수는 동일한 타입이 아니기 때문에 직접 더할 수 없습니다.

대신 이 예제에서는 `UInt16(one)` 을 호출하여 `one` 의 값을 새로운 `UInt16` 으로 초기화하고 기존 값 대신 초기화한 값을 사용합니다.

~~~ swift
let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
~~~

양쪽의 타입이 `UInt16` 이므로 덧셈은 이제 제대로 동작합니다.

출력 상수 `(twoThousandAndOne)` 은 두 `UInt16` 값을 더하므로 `UInt16` 타입으로 추론됩니다.

#

`SomeType (ofInitialValue)` 는 Swift 타입의 초기화를 호출하고 초기화 값을 전달하는 기본적인 방법입니다.

내부적으로 `UInt16` 은 `UInt8` 값을 허용하는 초기화가 있으므로 초기화는 기존 `UInt8` 에서 새 `UInt16` 을 만드는데 사용될 수 있었습니다.

그러나 여기서는 모든 타입을 전달할 수 있는것은 아닙니다.

`UInt16` 타입이 초기화를 제공하는 타입이어야 합니다.

기존 타입을 확장하여 새로운 타입 (자신이 정의한 새로운 타입) 을 받아들이는 초기화를 제공하는 것은 [확장 (Extensions)]() 에서 다룹니다.

<br>

### 정수와 부동 소수점 변환 (Integer and Floating-Point Conversion)














***

### ⬅️ [A Swift Tour](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/1.Welcome%20to%20Swift/3.A%20Swift%20Tour.md)

### ➡️ [Basic Operators](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/2.Basic%20Operators.md)
