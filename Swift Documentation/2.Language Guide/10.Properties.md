# Properties (프로퍼티)

인스턴스 또는 타입의 일부인 저장 및 계산된 값에 접근합니다.

프로퍼티 (Properties) 는 값을 특정 클래스, 구조체 또는 열거형과 연결합니다.

저장 프로퍼티 (Stored properties) 는 상수 및 변수 값을 인스턴스의 일부로 저장하는 반면 계산 프로퍼티 (Computed properties) 는 값을 저장하는 대신 값을 계산합니다.

계산 프로퍼티는 클래스, 구조체, 열거형으로 제공됩니다.

저장 프로퍼티는 클래스와 구조체에 의해서만 제공됩니다.

#

저장 및 계산 프로퍼티는 일반적으로 특정 타입의 인스턴스와 연결됩니다.

그러나 프로퍼티는 타입 자체와 연결될 수도 있습니다.

이러한 프로퍼티를 타입 프로퍼티라고 합니다.

#

또한 프로퍼티 관찰자 (property observers) 를 정의하여 프로퍼티 값의 변경 사항을 모니터링할 수 있으며 사용자 지정 작업으로 이에 응답할 수 있습니다.

프로퍼티 관찰자는 사용자가 직접 정의한 저장 프로퍼티와 하위 클래스가 상위 클래스에서 상속하는 프로퍼티에 추가할 수 있습니다.

#

프로퍼티 래퍼를 사용하여 여러 프로퍼티의 getter 와 setter 에서 코드를 재사용 할 수 있습니다.

<br>

## 저장 프로퍼티 (Stored Properties)

가장 간단한 형태로 저장 프로퍼티는 특정 클래스 또는 구조체의 인스턴스의 일부로 저장되는 상수 또는 변수 입니다.

저장 프로퍼티는 저장 프로퍼티 변수 (variable stored properties) (`var` 키워드 사용) 또는 저장 프로퍼티 상수 (constant stored properties) (`let` 키워드 사용) 로 쓸 수 있습니다.

#

[기본 프로퍼티 값 (Default Property Values)]() 에 설명된 대로 정의의 일부로 저장 프로퍼티에 대한 기본값을 제공할 수 있습니다.

초기화 중에 저장 프로퍼티의 초기값을 설정하고 수정할 수도 있습니다.

[초기화 중 프로퍼티 상수 할당 (Assigning Constant Properties During Initialization)]() 에서 설명된 대로 상수 저장 프로퍼티의 경우에도 마찬가지 입니다.

#

아래 예제는 `FixedLengthRange` 라는 구조체를 정의합니다.

이 구조체는 생성 후 범위 길이를 변경할 수 없는 정수 범위를 나타냅니다.

~~~ swift
struct FixedLengthRange {
    var firstValue: Int
    let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
// the range represents integer values 0, 1, and 2
rangeOfThreeItems.firstValue = 6
// the range now represents integer values 6, 7, and 8
~~~

`FixedLengthRange` 의 인스턴스에는 `firstValue` 라는 저장 프로퍼티 변수와 `length` 라는 저장 프로퍼티 상수가 있습니다.

위의 예제에서 `length` 는 새 범위가 생성될 때 초기화되며 상수 프로퍼티이기 때문에 이후에는 변경할 수 없습니다.

<br>

### 상수 구조체 인스턴스의 저장 프로퍼티 (Stored Properties of Constant Structure Instances)

구조체의 인스턴스를 생성하고 해당 인스턴스를 상수에 할당하면 프로퍼티 변수로 선언되어 있어도 인스턴스의 프로퍼티를 수정할 수 없습니다.

~~~ swift
let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
// this range represents integer values 0, 1, 2, and 3
rangeOfFourItems.firstValue = 6
// this will report an error, even though firstValue is a variable property
~~~

`rangeOfFourItems` 는 `let` 키워드를 사용하여 상수로 선언되므로 `firstValue` 가 프로퍼티 변수 이더라도 `firstValue` 프로퍼티를 변경할 수 없습니다.

#

이러한 동작은 구조체가 값 타입 이기 때문입니다.

값 타입의 인스턴스가 상수로 선언되면 해당 인스턴스의 모든 프로퍼티가 상수로 표시됩니다.

#

클래스는 참조 타입 이므로 다르게 동작합니다.

참조 타입의 인스턴스를 상수에 할당하면 해당 인스턴스의 프로퍼티 변수는 변경할 수 있습니다.

<br>

### 지연 저장 프로퍼티 (Lazy Stored Properties)

지연 저장 프로퍼티 (lazy stored property) 는 처음 사용될 때까지 초기값이 계산되지 않는 프로퍼티 입니다.

지연 저장 프로퍼티는 선언 앞에 `lazy` 수정자를 작성하여 나타냅니다.

> Note    
> 지연 저장 프로퍼티는 인스턴스 초기화가 완료될 때까지 초기값이 없을 수 있으므로 항상 `lazy` 키워드를 사용하여 변수로 선언해야 합니다.
> 상수 프로퍼티는 초기화가 완료되기 전에 항상 값을 가져야 하므로 지연 저장 프로퍼티로 선언할 수 없습니다.

#

지연 저장 프로퍼티는 인스턴스의 초기화가 완료될 때까지 값을 알 수 없는 외부 요인에 인해 초기값이 달라질 때 유용합니다.

지연 저장 프로퍼티는 프로퍼티의 초기값으로 필요할 때까지 수행하면 안되는 복잡하거나 계산 비용이 많이 드는 경우에도 유용합니다.

#

아래 예제는 복잡한 클래스의 불필요한 초기화를 피하기 위해 지연 저장 프로퍼티를 사용합니다.

이 예제에서는 `DataImporter` 와 `DataManager` 라는 2개의 클래스를 정의합니다.

~~~ swift
class DataImporter {
    /*
    DataImporter is a class to import data from an external file.
    The class is assumed to take a nontrivial amount of time to initialize.
    */
    var filename = "data.txt"
    // the DataImporter class would provide data importing functionality here
}


class DataManager {
    lazy var importer = DataImporter()
    var data: [String] = []
    // the DataManager class would provide data management functionality here
}


let manager = DataManager()
manager.data.append("Some data")
manager.data.append("Some more data")
// the DataImporter instance for the importer property hasn't yet been created
~~~

`DataManager` 클래스에는 `String` 값의 빈 배열로 초기화 되는 `data` 라는 저장 프로퍼티가 있습니다.

나머지 기능이 보이진 않지만 `DataManager` 클래스의 목적은 `String` 데이터 배열을 관리하고 이에 대한 접근을 제공하는 것입니다.

#

`DataManager` 클래스의 기능 중 하나는 파일에서 데이터를 가져오는 기능입니다.

이 기능은 `DataImporter` 클래스에서 제공되며 초기화 하는데 적지 않은 시간이 걸리는 것으로 간주됩니다.

이는 `DataImporter` 인스턴스가 초기화될 때 `DataImporter` 인스턴스가 파일을 열고 해당 내용을 메모리로 읽어야 하기 때문일 수 있습니다.

#

`DataManager` 인스턴스는 파일에서 데이터를 가져오지 않고도 데이터를 관리할 수 있으므로 `DataManager` 가 생성될 때 새로운 `DataImporter` 인스턴스를 생성할 필요가 없습니다.

대신 처음 사용하는 경우 `DataImporter` 인스턴스를 생성하는 것이 더 합리적입니다.

#

`lazy` 수정자로 표시되어 있기 때문에 `importer` 프로퍼티의 `DataImporter` 인스턴스는 `filename` 프로퍼티를 조회할 때 처럼 `importer` 프로퍼티에 처음 접근할 때만 생성됩니다.

~~~ swift
print(manager.importer.filename)
// the DataImporter instance for the importer property has now been created
// Prints "data.txt"
~~~

> Note    
> `lazy` 수정자로 표시된 프로퍼티는 여러 쓰레드에서 동시에 접근되고 프로퍼티가 아직 초기화되지 않은 경우 프로퍼티가 한번만 초기화 된다는 보장은 없습니다.

<br>

### 저장 프로퍼티와 인스턴스 변수 (Stored Properties and Instance Variables)

Objective-C 에 대한 경험이 있다면 클래스 인스턴스의 일부로 값과 참조를 저장하는 2가지 방법을 제공한다는 것을 알 수 있습니다.

프로퍼티 외에도 인스턴스 변수를 프로퍼티에 저장된 값에 대한 백업 저장소로 사용할 수 있습니다.

#

Swift 는 이러한 개념을 단일 프로퍼티 선언으로 통합합니다.

Swift 프로퍼티는 해당 인스턴스 변수가 없으며 프로퍼티의 백업 저장소에 직접적으로 접근할 수 없습니다.

이 접근 방식은 다양한 컨텍스트에서 값에 접근하는 방법에 대한 혼란을 방지하고 프로퍼티 선언을 하나의 명확한 구문으로 단순화 합니다.

이름, 타입 그리고 메모리 관리 특성을 포함하여 프로퍼티에 대한 모든 정보는 타입 정의의 일부로 한곳에서 정의됩니다.

<br>

## 계산 프로퍼티 (Computed Properties)

저장 프로퍼티 외에도 클래스, 구조체, 열거형은 실제로 값을 저장하지 않는 계산 프로퍼티 (computed properties) 를 정의할 수 있습니다.

대신 다른 프로퍼티와 값을 간접적으로 조회하고 설정하기 위한 getter 와 setter 그리고 옵셔널 setter 를 제공합니다.

~~~ swift
struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set(newCenter) {
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
    size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
// initialSquareCenter is at (5.0, 5.0)
square.center = Point(x: 15.0, y: 15.0)
print("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// Prints "square.origin is now at (10.0, 10.0)"
~~~

이 예제에서는 기하학적 모양 작업을 위한 3개의 구조체를 정의합니다.

- `Point` 는 x, y 좌표의 위치를 캡슐화 합니다.

- `Size` 는 `width` 와 `height` 를 캡슐화 합니다.

- `Rect` 는 원점과 크기로 사각형을 정의합니다.

#

`Rect` 구조체는 `center` 라는 계산 프로퍼티를 제공합니다.

`Rect` 의 현재 중심 위치는 항상 `origin` 과 `size` 로 결정될 수 있으므로 중심점을 명시적인 `Point` 값으로 저장할 필요가 없습니다.

대신 `Rect` 는 `center` 라는 계산된 변수에 대한 getter 와 setter 를 정의하고 실제 저장된 프로퍼티 처럼 사각형의 `center` 를 동작하도록 합니다.

#

위의 예제는 `square` 라는 새로운 `Rect` 변수를 생성합니다.

`square` 변수는 `(0, 0)` 의 원점, `10` 의 너비와 높이로 초기화 됩니다.

이 사각형은 아래의 다이어그램에서 연한 초록색 사격형으로 표현됩니다.

#

`square` 변수의 `center` 프로퍼티는 점 구문 (`square.center`) 로 접근되고 `center` 에 대한 getter 를 호출하여 현재 프로퍼티 값을 조회합니다.

기존 값을 반환하는 대신 getter 는 실제로 사각형의 중심을 나타내는 새로운 `Point` 값을 계산하고 반환합니다.

위에서 볼 수 있듯이 getter 는 `(5, 5)` 의 중심점을 올바르게 반환합니다.

#

아래 다이어그램의 어두운 초록색 사각형처럼 `center` 프로퍼티는 `(15, 15)` 의 새로운 값으로 설정되어 새로운 위치로 사각형이 위와 우측으로 이동합니다.

`center` 프로퍼티를 설정하면 `origin` 저장 프로퍼티의 `x` 와 `y` 값을 수정하고 사각형을 새로운 위치로 이동하는 `center` 의 setter 가 호출됩니다.

<img width="530" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/cb572d71-534d-4160-a05d-a4dcdba15dd4">

<br>

### 짧은 Setter 선언 (Shorthand Setter Declaration)

계산 프로퍼티의 setter 가 설정할 새 값의 이름을 정의하지 않으면 `newValue` 라는 기본 이름이 사용됩니다.

다음은 이 약식 표기법을 활용하는 `Rect` 구조체의 대체 버전입니다.

~~~ swift
struct AlternativeRect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set {
            origin.x = newValue.x - (size.width / 2)
            origin.y = newValue.y - (size.height / 2)
        }
    }
}
~~~

<br>

### 짧은 Getter 선언 (Shorthand Getter Declaration)

getter 의 전체 본문이 단일 표현식인 경우 getter 는 암시적으로 해당 표현식을 반환합니다.

다음은 getter 와 setter 의 약식 표기법을 활용하는 또 다른 버전의 `Rect` 구조체 입니다.

~~~ swift
struct CompactRect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            Point(x: origin.x + (size.width / 2),
                  y: origin.y + (size.height / 2))
        }
        set {
            origin.x = newValue.x - (size.width / 2)
            origin.y = newValue.y - (size.height / 2)
        }
    }
}
~~~

getter 에서 `return` 을 생략하는 것은 [암시적 반환을 사용하는 함수 (Function With an Implicit Return)]() 에 설명된 대로 함수의 `return` 생략 규칙과 동일합니다.

<br>

### 읽기 전용 계산 프로퍼티 (Read-Only Computed Properties)

setter 가 없고 getter 만 있는 계산 프로퍼티는 읽기 전용 계산 프로퍼티 (read-only computed property) 라고 합니다.

읽기 전용 계산 프로퍼티는 항상 값을 반환하고 점 구문으로 접근할 수 있지만 다른 값으로 설정할 수는 없습니다.

> Note    
> 값이 고정되어 있지 않기 때문에 읽기 전용 계산 프로퍼티를 포함하여 계산 프로퍼티는 `var` 키워드를 사용하여 변수 프로퍼티로 선언해야 합니다.
> `let` 키워드는 인스턴스 초기화의 일부로 한번 설정되면 값을 변경할 수 없음을 나타내기 위해 오직 상수 프로퍼티에서만 사용됩니다.

#

`get` 키워드와 중괄호를 제거하여 읽기 전용 계산 프로퍼티의 선언을 단순화할 수 있습니다.

~~~ swift
struct Cuboid {
    var width = 0.0, height = 0.0, depth = 0.0
    var volume: Double {
        return width * height * depth
    }
}
let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
// Prints "the volume of fourByFiveByTwo is 40.0"
~~~

이 예제는 `width`, `height`, `depth` 프로퍼티가 있는 3D 사각형 박스를 나타내는 `Cuboid` 라는 새로운 구조체를 정의 합니다.

이 구조체에는 직육면체의 현재 부피를 계산하고 반환하는 `volume` 이라는 읽기 전용 계산 프로퍼티가 있습니다.

`width`, `height`, `depth` 의 어떤 값을 특정 `volume` 값에 사용해야 하는지 모호하기 때문에 `volume` 을 설정 가능하게 하는 것은 의미가 없습니다.

그럼에도 불구하고 외부 사용자가 현재 계산된 부피를 알 수 있도록 읽기 전용 계산 프로퍼티를 제공하는 `Cuboid` 는 유용합니다.

<br>

## 프로퍼티 관찰자 (Property Observers)























***

### ⬅️ [Structures and Classes](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/9.Structures%20and%20Classes.md)

### ➡️ [Methods](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/11.Methods.md)
