# Initialization (초기화)

타입의 저장된 프로퍼티에 대한 초기값을 설정하고 초기 설정을 수행합니다.

#

초기화는 사용할 클래스, 구조체 또는 열거형의 인스턴스를 준비하는 단계입니다.

이 단계에는 해당 인스턴스의 각 저장 프로퍼티에 대한 초기값을 설정하고 새로운 인스턴스를 사용할 준비가 되기 전에 필요한 기타 설정 또는 초기화를 수행하는 작업이 포함됩니다.

#

특정 타입의 새로운 인스턴스를 생성하기 위해 호출할 수 있는 특수 메서드와 유사한 초기화 구문을 정의하여 초기화를 구현합니다.

Objective-C 초기화 구문과 달리 Swift 초기화 구문은 값을 반환하지 않습니다.

초기화의 주요 역할은 새로운 인스턴스가 처음 사용되기 전에 올바르게 초기화 되었는지 확인하는 것입니다.

#

클래스 타입의 인스턴스는 해당 클래스의 인스턴스가 할당 해제되기 직전에 사용자 정의 정리를 수행하는 초기화 해제 (deinitializer) 도 구현할 수 있습니다.

초기화 해제에 대한 자세한 내용은 [초기화 해제 (Deinitialization)]() 를 참조하세요.

<br>

## 저장 프로퍼티의 초기값 설정 (Setting Initial Values for Stored Properties)

클래스와 구조체는 해당 클래스나 구조체의 인스턴스가 생성될 때까지 모든 저장 프로퍼티에 적절한 초기값을 반드시 설정해야 합니다.

저장 프로퍼티는 불확실한 상태로 남겨질 수 없습니다.

#

이니셜라이저 내에서 또는 프로퍼티 정의 부분에서 기본 프로퍼티 값을 할당하여 저장 프로퍼티의 초기값을 설정할 수 있습니다.

이러한 작업은 다음 섹션에 설명되어 있습니다.

> Note    
> 저장 프로퍼티에 기본값을 할당하거나 이니셜라이저 내에서 초기값을 설정하면 해당 프로퍼티의 값은 모든 프로퍼티 관찰자 호출없이 직접 값이 설정됩니다.

<br>

### 초기화 구문 (Initializers)

특정 타입의 새로운 인스턴스를 생성하기 위해 초기화 구문이 호출됩니다.

가장 간단한 형태의 초기화 구문은 파라미터가 없는 인스턴스 메서드와 같으며 `init` 키워드를 사용하여 작성됩니다.

~~~ swift
init() {
    // perform some initialization here
}
~~~

#

아래 예제는 화씨 단위로 표현된 온도를 저장하기 위해 `Fahrenheit` 라는 새로운 구조체를 정의합니다.

`Fahrenheit` 구조체는 `Double` 타입의 `temperature` 라는 하나의 저장 프로퍼티가 있습니다.

~~~ swift
struct Fahrenheit {
    var temperature: Double
    init() {
        temperature = 32.0
    }
}
var f = Fahrenheit()
print("The default temperature is \(f.temperature)° Fahrenheit")
// Prints "The default temperature is 32.0° Fahrenheit"
~~~

이 구조체는 파라미터가 없고 `32.0` (화씨 단위의 물이 어는점) 의 값으로 초기화하는 `init` 의 단일 초기화 구문을 정의합니다.

<br>

### 기본 파라미터 값 (Default Property Values)

위에서 보았듯이 초기화 구문 내에서 저장 프로퍼티의 초기값을 설정할 수 있습니다.

또는 프로퍼티 선언의 일부로 기본 프로퍼티 값을 지정합니다.

프로퍼티가 정의될 때 프로퍼티에 초기값을 할당하여 기본 프로퍼티 값을 지정합니다.

> Note    
> 프로퍼티가 항상 동일한 초기값을 사용하는 경우 초기화 구문 내에서 값을 설정하기보다 기본값을 제공하세요.
> 결과는 같지만 기본값은 프로퍼티의 초기화를 해당 선언과 더 밀접하게 연결합니다.
> 이를 통해 더 짧고 명확한 초기화가 가능하며 기본값에서 프로퍼티의 타입을 추론할 수 있습니다.
> 또한 기본값은 이 챕터 후반부에 설명된 대로 기본 초기화 및 초기화 구문 상속을 더 쉽게 활용할 수 있습니다.

#

프로퍼티가 선언되는 시점에 `temperature` 에 기본값을 제공하여 위의 `Fahrenheit` 구조체를 더 간단한 형식으로 작성할 수 있습니다.

~~~ swift
struct Fahrenheit {
    var temperature = 32.0
}
~~~

<br>

## 초기화 구문 사용자 정의 (Customizing Initialization)

다음 섹션에 설명된 대로 입력 파라미터 및 옵셔널 프로퍼티 타입을 사용하거나 초기화 중에 상수 프로퍼티를 할당하여 초기화 단계를 사용자 정의할 수 있습니다.

<br>

### 초기화 파라미터 (Initialization Parameters)

초기화 파라미터를 초기화 정의의 일부로 제공하여 초기화 단계를 사용자 정의하는 값의 타입과 이름을 정의할 수 있습니다.

초기화 파라미터는 함수 및 메서드 파라미터와 동일한 기능 및 구문을 갖습니다.

#

다음 예제는 섭씨 온도로 표시되는 온도를 저장하는 `Celsius` 구조체를 정의합니다.

`Celsius` 구조체는 다른 온도 체계에서의 값으로 구조체의 새로운 인스턴스를 초기화하기 위해 `init(fromFahrenheit:)` 와 `init(fromKelvin:)` 이라고 하는 2개의 사용자 정의 초기화 구문을 구현합니다.

~~~ swift
struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius is 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius is 0.0
~~~

첫번째 초기화 구문은 `fromFahrenheit` 의 인수 레이블과 `fahrenheit` 의 파라미터 이름을 가진 단일 초기화 파라미터를 가지고 있습니다.

두번째 초기화 구문은 `fromKelvin` 의 인수 레이블과 `kelvin` 의 파라미터 이름을 가진 단일 초기화 파라미터를 가지고 있습니다.

두 초기화 구문은 모두 단일 인수를 해당 섭씨 값으로 변환하고 `temperatureInCelsius` 라는 프로퍼티에 값을 저장합니다.

<br>

### 파라미터 이름 및 인수 레이블 (Parameter Names and Argument Labels)

함수와 메서드 파라미터와 마찬가지로 초기화 파라미터에는 초기화 구문의 본문 내에서 사용할 파라미터 이름과 초기화 호출 시 사용할 인수 레이블이 모두 있을 수 있습니다.

#

그러나 초기화 구문에는 함수 및 메서드와 달리 소괄호 앞에 식별 함수 이름이 없습니다.

따라서 초기화 구문 파라미터의 이름과 타입은 어떤 초기화 구문을 호출해야 하는지 식별하는데 특히 중요한 역할을 합니다.

이 때문에 Swift 는 사용자가 파라미터를 제공하지 않을 경우 초기화의 모든 파라미터에 대해 자동 인수 레이블을 제공합니다.

#

다음 예제는 `red`, `green`, `blue` 라는 3가지 상수 프로퍼티를 사용하여 `Color` 라는 구조체를 정의합니다.

이러한 프로퍼티는 색상의 빨간색, 초록색, 파란색 의 양을 나타내는 `0.0` 과 `1.0` 사이의 값을 저장합니다.

#

`Color` 는 빨간색, 초록색, 파란색의 구성 요소에 대해 적절하게 이름이 지정된 3가지 `Double` 타입 파라미터가 있는 초기화 구문을 제공합니다.

`Color` 는 3가지 색상 구성 요소 모두에 대해 동일한 값을 제공할 때 사용되는 `white` 파라미터를 가진 두번째 초기화 구문을 제공합니다.

~~~ swift
struct Color {
    let red, green, blue: Double
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
    init(white: Double) {
        red   = white
        green = white
        blue  = white
    }
}
~~~

#

두 초기화 구문은 각 초기화 구문 파라미터에 명명된 값을 제공하여 새로운 `Color` 인스턴스를 생성하는데 사용할 수 있습니다.

~~~ swift
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)
~~~

#

인수 레이블을 사용하지 않고 이러한 초기화 구문을 호출하는 것은 불가능합니다.

인수 레이블은 정의 되었다면 항상 초기화에서 사용되어야 하고 생략하면 컴파일 타임 에러가 발생합니다.

~~~ swift
let veryGreen = Color(0.0, 1.0, 0.0)
// this reports a compile-time error - argument labels are required
~~~

<br>

### 인수 레이블이 없는 초기화 구문 파라미터 (Initializer Parameters Without Augument Labels)

초기화 파라미터에 인수 레이블을 사용하지 않으려면 파라미터에 대한 명시적인 인수 레이블 대신 언더바 (`_`) 를 작성하여 기본 동작을 재정의 합니다.

#

다음은 섭씨 온도에 대한 `Double` 값으로 새로운 `Celsius` 인스턴스를 생성하기 위한 추가 초기화 구문이 포함된 [초기화 파라미터 (Initialization Parameters)]() 의 `Celsius` 예제의 확장된 버전입니다.

~~~ swift
struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
    init(_ celsius: Double) {
        temperatureInCelsius = celsius
    }
}
let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius is 37.0
~~~

`Celsius(37.0)` 초기화 구문 호출은 인수 레이블이 필요 없이 의도가 명확합니다.

따라서 이름 없는 `Double` 값을 제공하여 호출할 수 있도록 `init(_ celsius: Double)` 초기화 구문을 작성하는 것이 적절합니다.

<br>

### 옵셔널 프로퍼티 타입 (Optional Property Types)

사용자 정의 타입에 논리적으로 "값 없음" 이 허용되는 저장 프로퍼티가 있는 경우 (초기화 중에 해당 값을 설정할 수 없거나 나중에 "값 없음" 을 가질 수 있기 때문)

해당 프로퍼티를 옵셔널 타입 프로퍼티로 선언합니다.

옵셔널 타입의 프로퍼티 값은 `nil` 값으로 자동 초기화됩니다.

이는 프로퍼티가 초기화 중에 "아직 값 없음" 을 가진다는 의도를 나타냅니다.

#

다음 예제는 `response` 라는 옵셔널 `String` 프로퍼티를 가지는 `SurveyQuestion` 이라는 클래스를 정의합니다.

~~~ swift
class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
cheeseQuestion.ask()
// Prints "Do you like cheese?"
cheeseQuestion.response = "Yes, I do like cheese."
~~~

설문조사 질문에 대한 응답은 질문을 받을 때까지 알 수 없으므로 `response` 프로퍼티 타입은 `String?` 또는 "옵셔널 `String`" 타입으로 선언됩니다.

`SurveyQuestion` 의 새로운 인스턴스가 초기화 되면 "아직 문자열 없음" 을 의미하는 기본값 `nil` 이 자동으로 할당됩니다.

<br>

### 초기화 중 상수 프로퍼티 할당 (Assigning Constant Properties During Initialization)

초기화가 완료될 때까지 명확한 값으로 설정되는 한 초기화 중 언제든지 상수 프로퍼티에 값을 할당할 수 있습니다.

상수 프로퍼티에 값이 할당되면 더 이상 수정할 수 없습니다.

> Note    
> 클래스 인스턴스의 경우 상수 프로퍼티는 해당 프로퍼티를 도입한 클래스에 의해서만 초기화 중에 수정될 수 있습니다.
> 하위 클래스에서는 수정할 수 없습니다.

#

위의 `SurveyQuestion` 예제를 수정하여 `text` 프로퍼티에 대해 변수 프로퍼티가 아닌 상수 프로퍼티를 사용하여 `SurveyQuestion` 인스턴스가 생성된 후에는 질문이 변경되지 않음을 나타낼 수 있습니다.

`text` 프로퍼티가 이제 상수 이더라도 클래스의 초기화 구문 내에서 계속 설정할 수 있습니다.

~~~ swift
class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let beetsQuestion = SurveyQuestion(text: "How about beets?")
beetsQuestion.ask()
// Prints "How about beets?"
beetsQuestion.response = "I also like beets. (But not with cheese.)"
~~~

<br>

## 기본 초기화 구문 (Default Initializers)

Swift 는 모든 프로퍼티에 대한 기본값을 제공하고 최소한 하나의 초기화 구문을 제공하지 않는 모든 구조체 또는 클래스에 대해 기본 초기화 구문을 제공합니다.

기본 초기화 구문은 모든 프로퍼티가 기본값으로 설정된 새로운 인스턴스를 생성합니다.

#

이 예제는 쇼핑 리스트에 있는 항목의 이름, 수량 그리고 구매 상태를 캡슐화하는 `ShoppingListItem` 클래스를 정의합니다.

~~~ swift
class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()
~~~

`ShoppingListItem` 클래스의 모든 프로퍼티는 기본값을 가지고 있고 상위 클래스가 없는 기본 클래스이기 때문에 모든 프로퍼티가 기본값으로 설정된 새로운 인스턴스를 생성하()는 기본 초기화 구현을 자동으로 갖습니다.

(`name` 프로퍼티는 코드에서 값을 작성하지 않았지만 옵셔널 `String` 프로퍼티 이므로 자동으로 기본값 `nil` 을 받습니다.)

위의 예제는 `ShoppingListItem` 클래스의 기본 초기화를 사용하여 클래스의 새로운 인스턴스를 생성합니다.

`ShoppingListItem()` 으로 작성된 초기화 구문을 사용하고 클래스의 새로운 인스턴스를 `item` 이라는 변수에 할당합니다.

<br>

### 구조체 타입에 대한 멤버별 초기화 구문 (Memberwise Initializers for Structure Types)

구조체 타입은 자체 사용자 정의 초기화 구문을 정의하지 않는 경우 자동으로 멤버별 초기화 구문을 받습니다.

기본 초기화 구문과 다르게 구조체는 기본값을 가지지 않는 저장 프로퍼티가 있더라도 멤버별 초기화 구문을 받습니다.

#

멤버별 초기화 구문은 새로운 구조체 인스턴스의 멤버 프로퍼티를 초기화하는 간단한 방법입니다.

새로운 인스턴스의 프로퍼티에 대한 초기값은 이름으로 멤버별 초기화 구문으로 전달될 수 있습니다.

#

아래 예제는 `width` 와 `height` 라는 2가지 프로퍼티를 가진 `Size` 구조체를 정의합니다.

두 프로퍼티 모두 `0.0` 의 기본값을 할당하여 `Double` 타입으로 추론됩니다.

#

`Size` 구조체는 새로운 `Size` 인스턴스를 초기화는데 사용할 수 있는 멤버별 초기화 `init(width:height:)` 를 자동으로 받습니다.

~~~ swift
struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
~~~

#

멤버별 초기화 구문을 호출할 때 기본값을 가지는 모든 프로퍼티의 값을 생략할 수 있습니다.

위의 예제에서 `Size` 구조체는 `height` 와 `width` 프로퍼티 모두 기본값을 가지고 있습니다.

프로퍼티 중 하나 또는 둘다 생략할 수 있고 초기화 구문은 생략된 항목에 대해 기본값을 사용합니다.

~~~ swift
let zeroByTwo = Size(height: 2.0)
print(zeroByTwo.width, zeroByTwo.height)
// Prints "0.0 2.0"


let zeroByZero = Size()
print(zeroByZero.width, zeroByZero.height)
// Prints "0.0 0.0"
~~~

<br>

## 값 타입에 대한 초기화 구문 위임 (Initializer Delegation for Value Types)

초기화 구문은 다른 초기화 구문을 호출하여 인스턴스 초기화의 일부를 수행할 수 있습니다.

초기화 구문 위임 이라는 이 프로세스는 여러 초기화 구문에서 코드가 중복되는 것을 방지합니다.

#

초기화 구문 위임이 작동하는 방식과 허용되는 위임 형식에 대한 규칙은 값 타입과 클래스 타입에 따라 다릅니다.

값 타입(구조체 및 열거형) 은 상속을 지원하지 않으므로 초기화 구문 위임 프로세스는 자신이 제공하는 다른 초기화에만 위임할 수 있기 때문에 상대적으로 간단합니다.

그러나 클래스는 [상속 (Inheritance)]() 에 설명된 대로 다른 클래스에서 상속할 수 있습니다.

이는 클래스가 상속하는 모든 저장 프로퍼티에 초기화 중에 적절한 값이 할당되도록 보장하는 추가 책임이 있음을 의미합니다.

이러한 책임은 아래 [클래스 상속 및 초기화 (Class Inheritance and Initialization)]() 에 설명되어 있습니다.

#

값 타입의 경우 사용자 정의 초기화 구문을 작성할 때 동일한 값 타입의 다른 초기화 구문을 참조하기 위해 `self.init` 을 사용합니다.

초기화 구문 내에서만 `self.init` 을 호출할 수 있습니다.

#

값 타입에 대해 사용자 정의 초기화 구문을 정의하면 해당 타입에 대한 기본 초기화 구문 또는 구조체의 경우 멤버별 초기화 구문에 더이상 접근할 수 없습니다.

이 제약은 자동 초기화 구문을 사용하는 누군가가 더 복잡한 초기화 구문에서 제공하는 추가 필수 설정을 실수로 우회하는 것을 방지합니다.

> Note    
> 사용자 정의 값 타입을 기본 초기화 구문과 멤버별 초기화 구문 및 사용자 정의 초기화 구문으로 초기화 하려면 값 타입의 원래 구현의 일부가 아닌 확장에 사용자 정의 초기화 구문을 작성하세요.
> 자세한 내용은 [확장 (Extensions)]() 를 참조하세요.

#

다음의 예제는 기하학적 직사각형을 나타내는 사용자 정의 `Rect` 구조체를 정의합니다.

이 예제는 `Size` 와 `Point` 라는 2개의 지원 구조체가 필요하고 둘 다 모든 프로퍼티에 대해 `0.0` 의 기본값을 제공합니다.

~~~ swift
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
~~~

#

아래의 `Rect` 구조체를 기본 값 0으로 초기화된 `origin` 과 `size` 프로퍼티 값을 사용하거나 특정 원점과 크기를 제공하거나 특정 중심점과 크기를 제공하는 3가지 방법중 하나로 초기화할 수 있습니다.

이러한 초기화 옵션은 `Rect` 구조체 정의의 일부인 3개의 사용자 정의 초기화 구문으로 표시됩니다.

~~~ swift
struct Rect {
    var origin = Point()
    var size = Size()
    init() {}
    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
~~~

첫번째 `Rect` 초기화 구문인 `init()` 은 자체 사용자 정의 초기화 구문이 없는 경우 구조체가 수신했을 기본 초기화 구문과 기능적으로 동일합니다.

이 초기화 구문은 빈 중괄호 `{}` 로 표시된 빈 본문을 가집니다.

이 초기화 구문을 호출하면 `origin` 과 `size` 프로퍼티는 프로퍼티 정의에서 `Point(x: 0.0, y: 0.0)` 과 `Size(width: 0.0, height: 0.0)` 의 기본값으로 초기화되는 `Rect` 인스턴스를 반환합니다.

~~~ swift
let basicRect = Rect()
// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)
~~~

#

두번째 `Rect` 초기화 구문인 `init(origin:size:)` 은 자체 사용자 정의 초기화 구문이 없는 경우 구조체가 수신했을 때 멤버별 초기화 구문과 기능적으로 동일합니다.

이 초기화 구문은 단순히 `origin` 과 `size` 인수값을 적절한 저장 프로퍼티에 할당합니다.

~~~ swift
let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
    size: Size(width: 5.0, height: 5.0))
// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)
~~~

#

세번째 `Rect` 초기화 구문인 `init(center:size:)` 는 좀 더 복잡합니다.

`center` 포인트와 `size` 값을 기반으로 적절한 원점을 계산하는 것으로 시작합니다.

그런 다음 적절한 프로퍼티에 새로운 원점과 크기 값을 저장하는 `init(origin:size:)` 초기화 구문을 호출 (또는 위임) 합니다.

~~~ swift
let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
    size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
~~~

`init(center:size:)` 초기화 구문은 적절한 프로퍼티 자체에 `origin` 과 `size` 의 새로운 값을 할당했을 수 있습니다.

그러나 `init(center:size)` 초기화 구문이 해당 기능을 이미 정확하게 제공하는 기존 초기화를 활용하는 것이 더 편리하고 의도가 더 명확합니다.

> Note    
> `init()` 과 `init(origin:size:)` 초기화 구문을 직접 정의하지 않고 이 예제를 작성하는 다른 방법은 [확장 (Extensions)]() 을 참조하세요.

<br>

## 클래스 상속과 초기화 (Class Inheritance and Initialization)

클래스가 상위 클래스에서 상속하는 모든 프로퍼티를 포함하여 클래스의 모든 저장 프로퍼티에는 초기화 중에 초기 값이 할당되어야 합니다.

#

Swift 는 모든 저장 프로퍼티가 초기값을 받을 수 있도록 돕기 위해 클래스 타입에 대해 2가지 종류의 초기화 구문을 정의합니다.

이를 지정 초기화 구문과 편의 초기화 구문 이라고 합니다.

<br>

### 지정 초기화 구문과 편의 초기화 구문 (Designated Initializers and Convenience Initializers)

지정 초기화 구문은 클래스의 기본 초기화 구문입니다.

지정 초기화는 해당 클래스에 의해 도입된 모든 프로퍼티를 완전히 초기화하고 적절한 상위 클래스 초기화를 호출하여 초기화 프로세스를 상위 클래스까지 연결하여 계속합니다.

#

클래스에는 지정 초기화 구문이 거의 없는 경향이 있으며 클래스에 하나만 있는 경우가 매우 일반적입니다.

지정 초기화 구문은 초기화가 수행되고 초기화 프로세스가 상위 클래스 체인까지 계속되는 "funnel" 지점입니다.

#

모든 클래스는 적어도 하나의 지정 초기화 구문이 있어야 합니다.

어떤 경우에는 아래의 [자동 초기화 구문 상속 (Automatic Initializer Inheritance)]() 에 설명된 대로 상위 클래스에서 하나 이상의 지정 초기화 구문을 상속하여 이 요구사항을 충족합니다.

#

편의 초기화는 클래스에 대한 초기화 구문을 지원하는 보조 초기화 구문입니다.

지정 초기화의 파라미터 중 일부를 기본값으로 설정하여 편의 초기화와 동일한 클래스에서 지정 초기화를 호출하도록 편의 초기화를 정의할 수 있습니다.

특정 사용 케이스 또는 입력 값 타입에 대한 해당 클래스의 인스턴스를 생성하기 위해 편의 초기화를 정의할 수도 있습니다.

#

클래스에서 필요하지 않은 경우 편의 초기화를 제공할 필요가 없습니다.

일반적인 초기화 패턴에 대한 바로가기가 시간을 절약하거나 클래스 초기화 의도를 더 명확하게 만들 때마다 편의 초기화를 만듭니다.

<br>

### 지정 및 편의 초기화 구문 (Syntax for Designated and Convenience Initializers)

클래스에 대한 지정 초기화 구문은 값 타입에 대한 간단한 초기화 구문과 동일한 방식으로 작성됩니다.

~~~ swift
init(<#parameters#>) {
   <#statements#>
}
~~~

#

편의 초기화 구문은 동일한 스타일로 작성되지만 `init` 키워드 앞에 `convenience` 수정자가 작성되고 공백으로 구분됩니다.

~~~ swift
convenience init(<#parameters#>) {
   <#statements#>
}
~~~

<br>

### 클래스 타입에 대한 초기화 위임 (Initializer Delegation for Class Types)

지정 초기화 구문과 편의 초기화 구문 사이의 관계를 단순화하기 위해 Swift 는 초기화 사이의 위임 호출에 대해 다음 3가지 규칙을 적용합니다.

**규칙 1**

- 지정 초기화 구문은 직계 상위 클래스의 지정 초기화 구문을 호출해야 합니다.

**규칙 2**

- 편의 초기화 구문은 동일한 클래스에서 다른 초기화를 호출해야 합니다.

**규칙 3**

- 편의 초기화 구문은 궁극적으로 지정 초기화 구문을 호출해야 합니다.

#

이것을 기억하는 간단한 방법은 다음과 같습니다.

- 지정 초기화 구문은 항상 위를 위임해야 합니다.

- 편의 초기화 구문은 항상 옆에 걸쳐 위임해야 합니다.

#

이러한 규칙은 아래의 그림에 설명되어 있습니다.

<img width="500" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/93ec426d-33a0-4310-9434-776f1fa63b90">

여기서 상위 클래스에는 하나의 지정 초기화와 2개의 편의 초기화가 있습니다.

하나의 편의 초기화는 또 다른 편의 초기화를 호출하고 이는 차례로 단일 지정 초기화를 호출합니다.

이는 위츼 규칙2 와 규칙3 을 만족합니다.

상위 클래스 자체에는 추가 상위 클래스가 없으므로 규칙1 이 적용되지 않습니다.

#

이 그림의 하위 클래스에는 2개의 지정 초기화와 하나의 편의 초기화가 있습니다.

편의 초기화는 동일한 클래스의 다른 초기화만 호출할 수 있으므로 2개의 지정 초기화 중 하나를 호출해야 합니다.

이는 위의 규칙2 와 3을 만족합니다.

위의 규칙1 을 충족하려면 2개의 지정 초기화 모두 상위 클래스에서 단일 지정 초기화를 호출해야 합니다.

> Note    
> 이러한 규칙은 클래스의 사용자가 각 클래스의 인스턴스를 생성하는 방법에 영향을 주지 않습니다.
> 위 다이어그램의 모든 초기화 구문은 자신이 속한 클래스의 완전히 초기화된 인스턴스를 만드는데 사용할 수 있습니다.
> 규칙은 클래스의 초기화 구현을 작성하는 방법에만 영향을 미칩니다.

#

아래 그림은 4개의 클래스에 대한 더 복잡한 클래스 계층 구조를 보여줍니다.

이 계층 구조의 지정 초기화 구문이 클래스 초기화를 위한 "funnel" 지점 역할을 하여 체인에 있는 클래스 간의 상호 관계를 단순화하는 방법을 보여줍니다.

<img width="500" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/fa11e073-af72-44a3-a7a7-df6ac1f1b1fc">

<br>

### 2단계 초기화 (Two-Phase Initialization)

Swift 의 클래스 초기화는 2단계 프로세스 입니다.

첫번째 단계에서는 각 저장 프로퍼티가 해당 프로퍼티를 도입한 클래스에 의해 초기값이 할당됩니다.

모든 저장 프로퍼티의 초기 상태가 결정되면 두번째 단계가 시작되고 각 클래스에는 새로운 인스턴스를 사용할 준비가 된 것으로 간주되기 전에 저장 프로퍼티를 추가로 사용자 정의할 수 있는 기회가 제공됩니다.

#

2단계 초기화 프로세스를 사용하면 초기화가 안전하게 이루어지며 클래스 계층 구조의 각 클래스에 완전한 유연성이 제공됩니다.

2단계 초기화는 프로퍼티 값이 초기화되기 전에 접근되는 것을 방지하고 프로퍼티 값이 예기치 않게 다른 초기화에 의해 다른 값으로 설정되는 것을 방지합니다.

> Note    
> Swift 의 2단계 초기화 프로세스는 Objective-C 의 초기화와 유사합니다.
> 주요 차이점은 1단계에서 Objective-C 는 모든 프로퍼티에 0 또는 null 값 (`0` 또는 `nil`) 을 할당한다는 것입니다.
> Swift 의 초기화 흐름은 사용자 정의 초기값을 설정할 수 있고 `0` 또는 `nil` 이 유효한 기본값이 아닌 타입에 대처할 수 있다는 점에서 더 유연합니다.

#

Swift 의 컴파일러는 2단계 초기화가 에러없이 완료되었는지 확인하기 위해 4가지 유용한 안전 검사를 수행합니다.

**안전 점검 1**

- 지정 초기화는 클래스에 의해 도입된 모든 프로퍼티가 상위 클래스 초기화에 위임되기 전에 초기화가 되도록 보장해야 합니다.

위에서 언급했듯이 객체의 메모리는 모든 저장 프로퍼티의 초기 상태가 알려진 후에만 완전히 초기화된 것으로 간주됩니다.

이 규칙을 충족하려면 지정 초기화는 체인을 전달하기 전에 모든 자체 프로퍼티가 초기화 되었는지 확인해야 합니다.

**안전 점검 2**

- 지정 초기화는 상속된 프로퍼티에 값을 할당하기 전에 상위 클래스 초기화에 위임해야 합니다. 그렇지 않으면 지정 초기화가 할당한 새 값은 자체 초기화의 일부로 상위 클래스에 의해 덮어 쓰여집니다.

**안전 점검 3**

- 편의 초기화는 모든 프로퍼티 (동일한 클래스에 의해 정의된 프로퍼티 포함) 에 값을 할당하기 전에 다른 초기화에 위임해야 합니다. 그렇지 않으면 편의 초기화가 할당한 새 값은 자체 클래스의 지정 초기화로 덮어 쓰여집니다. 

**안전 점검 4**

- 초기화는 첫번째 초기화 단계가 완료될 때까지 인스턴스 메서드를 호출하거나 인스턴스 프로퍼티값을 읽거나 `self` 값을 참조할 수 없습니다.

#

클래스 인스턴스는 첫번째 단계가 끝날 때까지 완전히 유효하지 않습니다.

첫번째 단계가 끝날 때 클래스 인스턴스가 유요한 것으로 판단된 후에만 프로퍼티에만 접근할 수 있고 메서드만 호출할 수 있습니다.

#

위의 4가지 안전 점검을 기반으로 2단계 초기화가 수행되는 방식은 아래와 같습니다.

**1 단계**

- 지정 또는 편의 초기화가 클래스에서 호출됩니다.

- 해당 클래스의 새로운 인스턴스에 대한 메모리가 할당됩니다. 메모리가 아직 초기화 되지 않았습니다.

- 해당 클래스의 지정 초기화는 클래스에 의해 도입된 모든 저장 프로퍼티가 값을 가지고 있는지 확인합니다. 이제 이러한 저장 프로퍼티에 대한 메모리가 초기화됩니다.

- 지정 초기화는 자신의 저장 프로퍼티에 대해 동일한 작업을 수행하기 위해 상위 클래스 초기화에 전달됩니다.

- 이것은 체인의 최상위에 도달할 때까지 클래스 상속 체인을 계속 진행합니다.

- 최상위 체인에 도달하고 체인의 마지막 클래스가 모든 저장 프로퍼티에 값이 있음을 확인하면 인스턴스의 메모리가 완전히 초기화된 것으로 간주되어 1단계가 완료됩니다.

#

**2 단계**

- 체인의 최상위에서 아래로 내려가면 체인의 각 지정 초기화에는 인스턴스를 추가로 사용자 정의할 수 있는 옵션이 있습니다. 초기화는 이제 해당 `self` 프로퍼티에 접근하여 수정하고 인스턴스 메서드를 호출하는 등의 작업을 수행할 수 있습니다.

- 마지막으로 체인의 모든 편의 초기화에는 인스턴스를 사용자 정의하고 `self` 로 작업할 수 있는 옵션이 있습니다.

#

다음은 1단계에서 가상의 하위 클래스 및 상위 클래스에 대한 초기화 호출을 찾는 방법을 나타냅니다.

<img width="500" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/efd3155b-462b-44b1-95fc-46f305a81daf">

이 예제에서 초기화는 하위 클래스의 편의 초기화 호출로 시작됩니다.

이 편의 초기화는 아직 어떤 프로퍼티도 수정할 수 없습니다.

동일한 클래스의 지정 초기화에 위임합니다.

#

지정 초기화는 안전 점검1 에 따라 하위 클래스의 모든 프로퍼티에 값이 있는지 확인합니다.

그런 다음 상위 클래스에서 지정 초기화를 호출하여 체인의 초기화를 계속합니다.

#

상위 클래스의 지정 초기화는 모든 상위 클래스 프로퍼티에 값이 있는지 확인합니다.

초기화 할 추가 상위 클래스가 없으므로 추가 위임이 필요하지 않습니다.

#

상위 클래스의 모든 프로퍼티가 초기값을 갖게 되면 해당 메모리는 완전히 초기화된 것으로 간주되어 1단계가 완료됩니다.

#

다음은 2단계에서 동일한 초기화 호출을 찾는 방법을 나타냅니다.

<img width="500" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/f0af4079-c4f2-4b22-a7b4-946d7d9ee10e">

이제 상위 클래스의 지정 초기화는 인스턴스를 추가로 사용자 정의할 수 있는 기회 (필수는 아님) 를 갖습니다.

#

상위 클래스의 지정 초기화가 완료되면 하위 클래스의 저정 초기화는 추가적인 사용자 정의를 수행할 수 있습니다.

#

마지막으로 하위 클래스의 지정 초기화가 완료되면 원래 호출되었던 편의 초기화가 추가 사용자 정의를 수행할 수 있습니다.

<br>

### 초기화 상속 및 재정의 (Initializer Inheritance and Overriding)

Objective-C 의 하위 클래스와 달리 Swift 하위 클래스는 기본적으로 상위 클래스 초기화 구문을 상속하지 않습니다.

Swift 의 접근 방식은 상위 클래스의 간단한 초기화가 보다 특수화된 하위 클래스에 의해 상속되고 완전히 또는 올바르게 초기화되지 않은 하위 클래스의 새로운 인스턴스를 생성하는데 사용되는 상황을 방지합니다.

> Note    
> 상위 클래스 초기화는 특정 상황에서 상속되지만 안전하고 적절한 경우에만 상속됩니다.
> 자세한 내용은 아래의 [자동 초기화 상속 (Automatic Initializer Inheritance)]() 을 참조하세요.

#

사용자 정의 하위 클래스가 상위 클래스와 동일한 초기화 구문 중 하나 이상을 제공하도록 하려면 하위 클래스 내에서 해당 초기화 구문의 사용자 정의 구현을 제공할 수 있습니다.

#

상위 클래스 지정 초기화 구문과 일치하는 하위 클래스 초기화 구문을 작성하면 해당 지정 초기화 구문의 재정의를 효과적으로 제공하는 것입니다.

따라서 하위 클래스의 초기화 정의 전에 `override` 수정자를 작성해야 합니다.

[기본 초기화 (Default Initializers)]() 에 설명된 대로 자동으로 제공되는 기본 초기화를 재정의하는 경우에도 마찬가지입니다.

#

재정의된 프로퍼티, 메서드 또는 서브 스크립트와 마찬가지로 `override` 수정자가 있으면 Swift 는 상위 클래스에 재정의 할 지정 초기화가 일치하는지 확인하고 재정의 할 초기화의 파라미터가 의도한대로 지정되었는지 확인합니다.

> Note    
> 하위 클래스의 초기화 구현이 편의 초기화인 경우에도 상위 클래스 지정 초기화를 재정의할 때 항상 `override` 수정자를 작성합니다.

#

반대로 상위 클래스의 편의 초기화와 일치하는 하위 클래스 초기화를 작성하는 경우 위의 [클래스 타입에 대한 초기화 위임 (Initializer Delegation for Class Types)]() 에 설명된 규칙에 따라 해당 상위 클래스 편의 초기화는 하위 클래스에서 직접 호출할 수 없습니다.

따라서 하위 클래스는 상위 클래스 초기화의 재정의를 제공하지 않습니다.

결과적으로 상위 클래스 편의 초기화의 일치하는 구현을 제공할 때 `override` 수정자를 작성하지 않습니다.

#

아래 예제는 `Vehicle` 이라는 기본 클래스를 정의합니다.

이 기본 클래스는 기본 `Int` 값 `0` 을 가진 `numberOfWheels` 라는 저장 프로퍼티를 선언합니다.

`numberOfWheels` 프로퍼티는 차량의 특성에 대한 설명하는 `String` 을 생성하기 위해 호출되는 `description` 이라는 계산 프로퍼티에 의해 사용됩니다.

~~~ swift
class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return "\(numberOfWheels) wheel(s)"
    }
}
~~~

#

`Vehicle` 클래스는 저장 프로퍼티에만 기본값을 제공하며 사용자 지정 초기화 자체는 제공하지 않습니다.

결과적으로 [기본 초기화 (Default Initializers)]() 에 설명된 대로 자동으로 기본 초기화를 받습니다.

기본 초기화는 사용 가능한 경우 항상 클래스에 대해 지정 초기화이며 기본값이 `0` 인 `numberOfWheels` 를 가진 새로운 `Vehicle` 인스턴스를 생성하기 위해 사용할 수 있습니다.

~~~ swift
let vehicle = Vehicle()
print("Vehicle: \(vehicle.description)")
// Vehicle: 0 wheel(s)
~~~

#

다음 예제는 `Bicycle` 이라는 `Vehicle` 의 하위 클래스를 정의합니다.

~~~ swift
class Bicycle: Vehicle {
    override init() {
        super.init()
        numberOfWheels = 2
    }
}
~~~

`Bicycle` 하위 클래스는 사용자 지정 지정 초기화인 `init()` 을 정의합니다.

이 지정 초기화 구문은 `Bicycle` 의 상위 클래스 지정 초기화 구문과 일치하므로 초기화 구문의 `Bicycle` 버전은 `override` 수정자가 표시됩니다.

#

`Bicycle` 의 `init()` 초기화 구문은 `Bicycle` 클래스의 상위 클래스인 `Vehicle` 에 대한 기본 초기화 구문을 호출하는 `super.init()` 을 호출하는 것으로 시작합니다.

이렇게 하면 상속된 `Vehicle` 프로퍼티가 이전에 초기화되어 `Bicycle` 이 `numberOfWheels` 프로퍼티를 수정할 기회를 갖게 됩니다.

`super.init()` 을 호출한 후에 `numberOfWheels` 의 기존 값이 새로운 값 `2` 로 대체됩니다.

#

`Bicycle` 의 인스턴스를 생성하는 경우 상속된 `description` 계산 프로퍼티를 호출하여 해당 `numberOfWheels` 프로퍼티가 어떻게 업데이트 되었는지 확인할 수 있습니다.

~~~ swift
let bicycle = Bicycle()
print("Bicycle: \(bicycle.description)")
// Bicycle: 2 wheel(s)
~~~

#

하위 클래스 초기화 구문이 초기화 프로세스의 2단계에서 사용자 정의를 수행하지 않고 상위 클래스가 동기적이며 인수가 없는 지정 초기화 구문을 가지고 있는 경우 하위 클래스의 모든 저장 프로퍼티에 값을 할당한 후 `super.init()` 호출을 생략할 수 있습니다.

상위 클래스의 초기화 구문이 비동기적이라면 명시적으로 `await super.init()` 을 작성해야 합니다.

#

아래 예제는 `Hoverboard` 라는 `Vehicle` 의 또 다른 하위 클래스를 정의합니다.

초기화 구문에서 `Hoverboard` 클래스는 `color` 프로퍼티만 설정합니다.

이 초기화 구문은 `super.init()` 을 명시적으로 호출하는 대신 상위 클래스의 초기화 구문을 암시적으로 호출함으로써 프로세스를 완료합니다.

~~~ swift
class Hoverboard: Vehicle {
    var color: String
    init(color: String) {
        self.color = color
        // super.init() implicitly called here
    }
    override var description: String {
        return "\(super.description) in a beautiful \(color)"
    }
}
~~~

#

`Hoverboard` 의 인스턴스는 `Vehicle` 초기화 구문에 의해 제공된 바퀴의 기본 갯수를 사용합니다.

~~~ swift
let hoverboard = Hoverboard(color: "silver")
print("Hoverboard: \(hoverboard.description)")
// Hoverboard: 0 wheel(s) in a beautiful silver
~~~

> Note    
> 하위 클래스는 초기화 중에 상속된 변수 프로퍼티를 수정할 수 있지만 상속된 상수 프로퍼티는 수정할 수 없습니다.

<br>

### 자동 초기화 상속 (Automatic Initializer Inheritance)

위에서 언급한 것처럼 하위 클래스는 기본적으로 상위 클래스 초기화를 상속하지 않습니다.

그러나 특정 조건이 충족되면 상위 클래스 초기화가 자동으로 상속됩니다.

실제로 이것은 대부분의 경우에 초기화 재정의를 작성할 필요가 없으며 안전하다면 상위 클래스 초기화를 최소한의 노력으로 상속할 수 있습니다.

#

하위 클래스에 도입하는 모든 새로운 프로퍼티에 기본값을 제공하면 아래의 2가지 규칙이 적용됩니다.

**규칙 1**

- 하위 클래스가 지정 초기화를 정의하지 않으면 상위 클래스의 모든 지정 초기화를 자동으로 상속받습니다.

**규칙 2**

- 하위 클래스가 규칙 1에 따라 상속하거나 정의의 일부분으로 사용자 정의 구현을 제공하여 모든 상위 클래스 지정 초기화의 구현을 제공하는 경우 자동으로 모든 상위 클래스의 편의 초기화를 상속합니다.

이러한 규칙은 하위 클래스가 편의 초기화를 추가하는 경우에도 적용됩니다.

> Note    
> 하위 클래스는 규칙 2를 충족하는 일부분으로 상위 클래스 지정 초기화를 하위 클래스 편의 초기화로 구현할 수 있습니다.

<br>

### 지정 초기화 및 편의 초기화 동작 (Designated and Convenience Initializers in Action)

다음 예제는 지정 초기화, 편의 초기화 그리고 자동 초기화 상속이 실행되는 동작을 보여줍니다.

이 예제는 `Food`, `RecipeIngredient` 그리고 `ShoppingListItem` 이라는 3개의 클래스 계층 구조를 정의하고 해당 초기화가 상호 작용하는 방식을 보여줍니다.

#

계층 구조의 기본 클래스는 식품 이름을 캡슐화하는 간단한 클래스인 `Food` 라고 합니다.

`Food` 클래스는 `name` 이라는 단일 `String` 프로퍼티를 도입하고 `Food` 인스턴스 생성을 위한 2개의 초기화를 제공합니다.

~~~ swift
class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: "[Unnamed]")
    }
}
~~~

#

아래 그림은 `Food` 클래스의 초기화 체인을 보여줍니다.

<img width="500" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/8f35a96b-1fb2-423f-a297-01557ea96975">

클래스는 기본 멤버별 초기화가 없으므로 `Food` 클래스는 `name` 이라는 단일 인수를 가지는 지정 초기화를 제공합니다.

이 초기화는 특정 이름을 가진 새로운 `Food` 인스턴스를 생성하는데 사용될 수 있습니다.

~~~ swift
let namedMeat = Food(name: "Bacon")
// namedMeat's name is "Bacon"
~~~

#

`Food` 클래스의 `init(name: String)` 초기화는 새로운 `Food` 인스턴스의 모든 저장 프로퍼티가 완전히 초기화되도록 보장하기 때문에 지정 초기화로 제공됩니다.

`Food` 클래스는 상위 클래스가 없으므로 `init(name: String)` 초기화는 초기화를 완료하기 위해 `super.init()` 을 호출할 필요가 없습니다.

#

`Food` 클래스는 인수가 없는 `init()` 편의 초기화도 제공합니다.

`init()` 초기화는 `[Unnamed]` 의 `name` 값으로 `Food` 클래스의 `init(name: String)` 에 위임하여 새로운 음식에 대한 기본 이름을 제공합니다.

~~~ swift
let mysteryMeat = Food()
// mysteryMeat's name is "[Unnamed]"
~~~

#

계층 구조의 두번째 클래스는 `RecipeIngredient` 라는 `Food` 의 하위 클래스 입니다.

`RecipeIngredient` 클래스는 요리 레시피의 재료를 모델링합니다.

`quantity` (`Food` 에서 상속 받은 `name` 프로퍼티 외에도) 라는 `Int` 프로퍼티를 도입하고 `RecipeIngredient` 인스턴스 생성을 위한 2개의 초기화를 정의합니다.

~~~ swift
class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}
~~~

#

아래 그림은 `RecipeIngredient` 클래스의 초기화 체인을 보여줍니다.

<img width="500" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/3cc5ba80-2e57-4e77-8ab8-1da27a598bf4">

`RecipeIngredient` 클래스는 새로운 `RecipeIngredient` 인스턴스의 모든 프로퍼티를 채우는데 사용할 수 있는 `init(name: String, quantity: String)` 단일 지정 초기화를 가지고 있습니다.

이 초기화는 `RecipeIngredient` 에 도입된 새로운 프로퍼티인 `quantity` 프로퍼티에 전달된 `quantity` 인수를 할당하는 것으로 시작합니다.

그런 다음 `Food` 클래스의 `init(name: String)` 초기화에 위임합니다.

이 과정은 위에서 설명한 [2단계 초기화 (Two-Phase Initialization)]() 의 안전 점검 1 을 만족합니다.

#

`RecipeIngredient` 는 이름으로만 `RecipeIngredient` 인스턴스를 생성하는데 사용되는 `init(name: String)` 편의 초기화를 정의합니다.

이 편의 초기화는 명시적인 수량 없이 생성되는 모든 `RecipeIngredient` 인스턴스에 대해 `1` 의 수량으로 가정합니다.

이러한 편의 초기화 정의는 `RecipeIngredient` 인스턴스를 더 빠르고 편리하게 생성하도록 하고 여러개의 단일 수량 `RecipeIngredient` 인스턴스를 생성할 때 코드 중복을 방지합니다.

이 편의 초기화는 단순히 `quantity` 값 `1` 을 전달하여 클래스의 지정 초기화에 위임합니다.

#

`RecipeIngredient` 에서 제공하는 `init(name: String)` 편의 초기화는 `Food` 의 지정 초기화 `init(name: String)` 과 동일한 파라미터를 사용합니다.

이 편의 초기화는 상위 클래스의 지정 초기화를 재정의하기 때문에 [초기화 상속 및 재정의 (Initializer Inheritance and Overriding)]() 에서 설명한 대로 `override` 수정자를 붙여줘야 합니다.

#

`RecipeIngredient` 는 편의 초기화로 `init(name: String)` 초기화를 제공 하더라도 `RecipeIngredient` 는 상위 클래스의 모든 지정 초기화의 구현을 제공합니다.

따라서 `RecipeIngredient` 는 상위 클래스의 모든 편의 초기화도 자동으로 상속합니다.

#

이 예제에서 `RecipeIngredient` 의 상위 클래스에는 `init()` 이라는 단일 편의 초기화가 있습니다.

따라서 이 초기화는 `RecipeIngredient` 에 상속됩니다.

상속된 `init()` 버전의 기능은 `Food` 버전이 아닌 `RecipeIngredient` 버전의 `init(name: String)` 에 위임된다는 점을 제외하면 `Food` 버전과 정확히 동일한 방식으로 작동합니다.

#

이 3가지 초기화 모두 새로운 `RecipeIngredient` 인스턴스를 생성하는데 사용할 수 있습니다.

~~~ swift
let oneMysteryItem = RecipeIngredient()
let oneBacon = RecipeIngredient(name: "Bacon")
let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)
~~~

#

계층 구조의 세번째이자 마지막 클래스는 `RecipeIngredient` 의 하위 클래스 `ShoppingListItem` 입니다.

`ShoppingListItem` 클래스는 쇼핑 리스트에 표시되는 레시피 재료를 모델링 합니다.

#

쇼핑 리스트의 모든 항목은 "구매하지 않음" 으로 시작됩니다.

이것을 표현하기 위해 `ShoppingListItem` 은 기본값이 `false` 인 `purchased` 부울 프로퍼티를 도입합니다.

또한 `ShoppingListItem` 은 `ShoppingListItem` 인스턴스의 텍스트 설명을 제공하는 계산 프로퍼티 `description` 을 추가합니다.

~~~ swift
class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = "\(quantity) x \(name)"
        output += purchased ? " ✔" : " ✘"
        return output
    }
}
~~~

> Note    
> `ShoppingListItem` 의 `purchased` 에 대한 초기값을 제공하기 위해 초기화를 정의하지 않습니다.
> 왜냐하면 여기서 모델링된 대로 쇼핑 리스트 항목은 항상 구매되지 않은 상태에서 시작되기 때문입니다.

#

도입한 모든 프로퍼티에 대한 기본값을 제공하고 초기화 자체를 정의하지 않기 때문에 `ShoppingListItem` 은 자동으로 상위 클래스에서 지정 초기화와 편의 초기화 모두 상속합니다.

#

아래 그림은 세 클래스 모두에 대한 전체 초기화 체인을 보여줍니다.

<img width="500" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/1d637a4b-0a44-4ad8-8a68-4e1487421d61">

#

상속된 초기화 3개를 모두 사용하여 새로운 `ShoppingListItem` 인스턴스를 생성할 수 있습니다.

~~~ swift
var breakfastList = [
    ShoppingListItem(),
    ShoppingListItem(name: "Bacon"),
    ShoppingListItem(name: "Eggs", quantity: 6),
]
breakfastList[0].name = "Orange juice"
breakfastList[0].purchased = true
for item in breakfastList {
    print(item.description)
}
// 1 x Orange juice ✔
// 1 x Bacon ✘
// 6 x Eggs ✘
~~~

여기서 3개의 새로운 `ShoppingListItem` 인스턴스를 포함하는 새로운 배열 `breakfastList` 가 생성됩니다.

배열의 타입은 `[ShoppingListItem]` 으로 추론됩니다.

배열이 생성된 후에 배열의 첫번째 `ShoppingListItem` 에 이름이 `"[Unnamed]"` 에서 `"Orange juice"` 로 변경되고 구매된 것으로 표시됩니다.

배열의 각 항목에 대한 설명을 출력하면 해당 항목의 기본 상태가 예상대로 설정되었음을 알 수 있습니다.

<br>

## 실패 가능한 초기화 (Failable Initializers)

초기화가 실패할 수 있는 클래스, 구조체 또는 열거형을 정의하는 것이 유용한 경우가 있습니다.

이 실패는 잘못된 초기화 파라미터 값, 필수 외부 리소스 부재 또는 초기화 성공을 방해하는 기타 조건으로 인해 발생할 수 있습니다.

#

실패할 수 있는 초기화 조건에 대처하려면 클래스, 구조체 또는 열거형 정의의 일부로 실패할 수 있는 하나 이상의 초기화를 정의하세요.

`init` 키워드 뒤에 물음표를 배치하여 실패할 수 있는 초기화를 작성합니다(`init?`).

> Note    
> 동일한 파라미터 타입과 이름을 사용하여 실패 가능한 초기화와 실패 불가능한 초기화를 정의할 수 없습니다.

#

실패 가능한 초기화는 초기화하는 타입의 옵셔널값을 생성합니다.

초기화 실패가 트리거될 수 있는 지점을 나타내기 위해 실패할 수 있는 초기화 내에 `return nil` 을 작성합니다.

> Note    
> 엄밀히 말하면 초기화는 값을 반환하지 않습니다.
> 오히려 그들의 역할은 초기화가 끝날 때까지 `self` 가 완전하고 정확하게 초기화 되도록 하는 것입니다.
> 초기화 실패를 트리거 하기 위해 `return nil` 을 작성했지만 초기화 성공을 나타내기 위해 `return` 키워드를 사용하지 않습니다.

#

예를 들어 숫자 타입 변환을 위해 실패 가능한 초기화 구현됩니다.

숫자 타입 간의 변환이 값을 정확하게 유지하도록 하려면 `init(exactly:)` 초기화를 사용합니다.

타입 변환이 값을 유지할 수 없으면 초기화는 실패합니다.

~~~ swift
let wholeNumber: Double = 12345.0
let pi = 3.14159


if let valueMaintained = Int(exactly: wholeNumber) {
    print("\(wholeNumber) conversion to Int maintains value of \(valueMaintained)")
}
// Prints "12345.0 conversion to Int maintains value of 12345"


let valueChanged = Int(exactly: pi)
// valueChanged is of type Int?, not Int


if valueChanged == nil {
    print("\(pi) conversion to Int doesn't maintain value")
}
// Prints "3.14159 conversion to Int doesn't maintain value"
~~~

#

아래 예제는 `species` 라는 `String` 상수 프로퍼티를 가진 `Animal` 구조체를 정의합니다.

`Animal` 구조체는 `species` 라는 단일 파라미터를 사용하여 실패 가능한 초기화를 정의합니다.

이 초기화는 초기화에 전달된 `species` 값이 빈 문자열인지 확인합니다.

빈 문자열이 발견되면 초기화 실패가 트리거됩니다.

그렇지 않으면 `species` 프로퍼티 값이 설정되고 초기화가 성공합니다.

~~~ swift
struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}
~~~

#

이 실패 가능한 초기화를 사용하여 새로운 `Animal` 인스턴스 초기화를 시도하고 초기화 성공 여부를 확인할 수 있습니다.

~~~ swift
let someCreature = Animal(species: "Giraffe")
// someCreature is of type Animal?, not Animal


if let giraffe = someCreature {
    print("An animal was initialized with a species of \(giraffe.species)")
}
// Prints "An animal was initialized with a species of Giraffe"
~~~

#

실패 가능한 초기화의 `species` 파라미터에 빈 문자열 값을 전달하면 초기화가 초기화 실패를 트리거합니다.

~~~ swift
let anonymousCreature = Animal(species: "")
// anonymousCreature is of type Animal?, not Animal


if anonymousCreature == nil {
    print("The anonymous creature couldn't be initialized")
}
// Prints "The anonymous creature couldn't be initialized"
~~~

> Note    
> `"Giraffe"` 대신 `""` 와 같은 빈 문자열 값을 확인하는 것은 옵셔널 `String` 에 값이 없음을 나타내는 `nil` 을 확인하는 것과 다릅니다.
> 위의 예제에서 빈 문자열 `""` 은 옵셔널이 아닌 유효한 `String` 문자열입니다.
> 그러나 동물의 `species` 프로퍼티값으로 빈 문자열을 갖는 것은 적절하지 않습니다.
> 이 제한 사항을 모델링 하기 위해 실패 가능한 초기화는 빈 문자열이 발견되면 초기화 실패를 트리거합니다.

<br>

### 열거형을 위한 실패 가능한 초기화 (Failable Initializers for Enumerations)

실패 가능한 초기화를 사용하여 하나 이사으이 파라미터를 기반으로 적절한 열거형 케이스를 선택할 수 있습니다.

제공된 파라미터가 적절한 열거형 케이스와 일치하지 않으면 초기화가 실패할 수 있습니다.

#

아래 예제는 3가지 가능한 상태 (`kelvin`, `celsius`, `fahrenheit`) 를 가진 `TemperatureUnit` 이라는 열거형을 정의합니다.

실패 가능한 초기화는 온도 기호를 나타내는 `Character` 값에 대한 적절한 열거형 케이스를 찾는데 사용됩니다.

~~~ swift
enum TemperatureUnit {
    case kelvin, celsius, fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case "K":
            self = .kelvin
        case "C":
            self = .celsius
        case "F":
            self = .fahrenheit
        default:
            return nil
        }
    }
}
~~~

#

해당 실패 가능한 초기화를 사용하여 3가지 가능한 상태에 대한 적절한 열거형 케이스를 선택하고 파라미터가 어떠한 상태도 일치하지 않은 경우 초기화가 실패하도록 할 수 있습니다.

~~~ swift
let fahrenheitUnit = TemperatureUnit(symbol: "F")
if fahrenheitUnit != nil {
    print("This is a defined temperature unit, so initialization succeeded.")
}
// Prints "This is a defined temperature unit, so initialization succeeded."


let unknownUnit = TemperatureUnit(symbol: "X")
if unknownUnit == nil {
    print("This isn't a defined temperature unit, so initialization failed.")
}
// Prints "This isn't a defined temperature unit, so initialization failed."
~~~

<br>

### 원시값이 있는 열거형에 대한 실패 가능한 초기화 (Failable Initializers for Enumerations with Raw Values)

원시값이 있는 열거형은 적절한 원시값 타입의 `rawValue` 파라미터를 사용하고 일치하는 값을 찾으면 일치하는 열거형 케이스를 선택하거나 일치하는 값이 없으면 초기화 실패를 트리거하는 실패 가능한 초기화 `init?(rawValue:)` 를 자동으로 받습니다.

#

위의 `TemperatureUnit` 예제를 다시 작성하여 `Character` 타입의 원시값을 사용하고 `init?(rawValue:)` 초기화를 활용할 수 있습니다.

~~~ swift
enum TemperatureUnit: Character {
    case kelvin = "K", celsius = "C", fahrenheit = "F"
}

let fahrenheitUnit = TemperatureUnit(rawValue: "F")
if fahrenheitUnit != nil {
    print("This is a defined temperature unit, so initialization succeeded.")
}
// Prints "This is a defined temperature unit, so initialization succeeded."

let unknownUnit = TemperatureUnit(rawValue: "X")
if unknownUnit == nil {
    print("This isn't a defined temperature unit, so initialization failed.")
}
// Prints "This isn't a defined temperature unit, so initialization failed."
~~~

<br>

### 초기화 실패 전파 (Propagation of Initialization Failure)

클래스, 구조체 또는 열거형의 실패 가능한 초기화는 동일한 클래스, 구조체 또는 열거형의 실패 가능한 다른 초기화에 위임할 수 있습니다.

마찬가지로 하위 클래스의 실패 가능한 초기화는 상위 클래스의 실패 가능한 초기화까지 위임할 수 있습니다.

#

두 경우 모두 초기화 실패를 유발하는 다른 초기화에 위임하면 전체 초기화 프로세스가 즉시 실패하고 추가 초기화 코드가 실행되지 않습니다.

> Note    
> 실패 가능한 초기화는 실패할 수 없는 초기화에 위임할 수도 있습니다.
> 실패하지 않는 기존 초기화 프로세스에 실패 상태를 추가해야 하는 경우에 이 접근 방식을 사용합니다.

#

아래 예제는 `CartItem` 이라는 `Product` 의 하위 클래스를 정의합니다.

`CartItem` 클래스는 온라인 장바구니에 있는 상품을 모델링합니다.

`CartItem` 은 `quantity` 라는 상수 저장 프로퍼티를 도입하고 이 프로퍼티는 최소한 `1` 이상의 값을 갖도록 보장합니다.

~~~ swift
class Product {
    let name: String
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}


class CartItem: Product {
    let quantity: Int
    init?(name: String, quantity: Int) {
        if quantity < 1 { return nil }
        self.quantity = quantity
        super.init(name: name)
    }
}
~~~

`CartItem` 의 실패 가능한 초기화는 `quantity` 값에 `1` 또는 그 이상의 값을 받았는지 확인하는 것으로 시작됩니다.

`quantity` 가 유효하지 않은 경우 전체 초기화 프로세스가 즉시 실패하고 더이상 추가 초기화 코드가 실행되지 않습니다.

마찬가지로 `Product` 에 대한 실패 가능한 초기화는 `name` 값을 확인하고 `name` 이 빈 문자열이면 초기화 프로세스가 즉시 실패합니다.

#

비어 있지 않은 이름과 `1` 또는 그 이상의 수량으로 `CartItem` 인스턴스를 생성하면 초기화가 성공합니다.

~~~ swift
if let twoSocks = CartItem(name: "sock", quantity: 2) {
    print("Item: \(twoSocks.name), quantity: \(twoSocks.quantity)")
}
// Prints "Item: sock, quantity: 2"
~~~

#

`0` 의 `quantity` 값을 가진 `CartItem` 인스턴스를 생성하려고 하면 `CartItem` 초기화는 초기화에 실패합니다.

~~~ swift
if let zeroShirts = CartItem(name: "shirt", quantity: 0) {
    print("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")
} else {
    print("Unable to initialize zero shirts")
}
// Prints "Unable to initialize zero shirts"
~~~

#

마찬가지로 빈 `name` 을 가진 `CartItem` 인스턴스를 생성하려고 하면 상위 클래스 `Product` 초기화로 인해 초기화가 실패합니다.

~~~ swift
if let oneUnnamed = CartItem(name: "", quantity: 1) {
    print("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")
} else {
    print("Unable to initialize one unnamed product")
}
// Prints "Unable to initialize one unnamed product"
~~~

<br>

### 실패 가능한 초기화 재정의 (Overriding a Failable Initializer)









***

### ⬅️ [Inheritance](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/13.Inheritance.md)

### ➡️ [Deinitialization](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/15.Deinitialization.md)
