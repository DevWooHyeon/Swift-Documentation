# Initialization (초기화)

타입의 저장된 프로퍼티에 대한 초기값을 설정하고 초기 설정을 수행합니다.

#

초기화는 사용할 클래스, 구조체 또는 열거형의 인스턴스를 준비하는 단계입니다.

이 단계에는 해당 인스턴스의 각 저장 프로퍼티에 대한 초기값을 설정하고 새로운 인스턴스를 사용할 준비가 되기 전에 필요한 기타 설정 또는 초기화를 수행하는 작업이 포함됩니다.

#

특정 타입의 새로운 인스턴스를 생성하기 위해 호출할 수 있는 특수 메서드와 유사한 초기화 구문을 정의하여 초기화를 구현합니다.

Objective-C 초기화 구문과 달리 Swift 초기화 구문은 값을 반환하지 않습니다.

초기화의 주요 역할은 새로운 인스턴스가 처음 사용되기 전에 올바르게 초기화 되었는지 확인하는 것입니다.

#

클래스 타입의 인스턴스는 해당 클래스의 인스턴스가 할당 해제되기 직전에 사용자 정의 정리를 수행하는 초기화 해제 (deinitializer) 도 구현할 수 있습니다.

초기화 해제에 대한 자세한 내용은 [초기화 해제 (Deinitialization)]() 를 참조하세요.

<br>

## 저장 프로퍼티의 초기값 설정 (Setting Initial Values for Stored Properties)

클래스와 구조체는 해당 클래스나 구조체의 인스턴스가 생성될 때까지 모든 저장 프로퍼티에 적절한 초기값을 반드시 설정해야 합니다.

저장 프로퍼티는 불확실한 상태로 남겨질 수 없습니다.

#

이니셜라이저 내에서 또는 프로퍼티 정의 부분에서 기본 프로퍼티 값을 할당하여 저장 프로퍼티의 초기값을 설정할 수 있습니다.

이러한 작업은 다음 섹션에 설명되어 있습니다.

> Note    
> 저장 프로퍼티에 기본값을 할당하거나 이니셜라이저 내에서 초기값을 설정하면 해당 프로퍼티의 값은 모든 프로퍼티 관찰자 호출없이 직접 값이 설정됩니다.

<br>

### 초기화 구문 (Initializers)

특정 타입의 새로운 인스턴스를 생성하기 위해 초기화 구문이 호출됩니다.

가장 간단한 형태의 초기화 구문은 파라미터가 없는 인스턴스 메서드와 같으며 `init` 키워드를 사용하여 작성됩니다.

~~~ swift
init() {
    // perform some initialization here
}
~~~

#

아래 예제는 화씨 단위로 표현된 온도를 저장하기 위해 `Fahrenheit` 라는 새로운 구조체를 정의합니다.

`Fahrenheit` 구조체는 `Double` 타입의 `temperature` 라는 하나의 저장 프로퍼티가 있습니다.

~~~ swift
struct Fahrenheit {
    var temperature: Double
    init() {
        temperature = 32.0
    }
}
var f = Fahrenheit()
print("The default temperature is \(f.temperature)° Fahrenheit")
// Prints "The default temperature is 32.0° Fahrenheit"
~~~

이 구조체는 파라미터가 없고 `32.0` (화씨 단위의 물이 어는점) 의 값으로 초기화하는 `init` 의 단일 초기화 구문을 정의합니다.

<br>

### 기본 파라미터 값 (Default Property Values)

위에서 보았듯이 초기화 구문 내에서 저장 프로퍼티의 초기값을 설정할 수 있습니다.

또는 프로퍼티 선언의 일부로 기본 프로퍼티 값을 지정합니다.

프로퍼티가 정의될 때 프로퍼티에 초기값을 할당하여 기본 프로퍼티 값을 지정합니다.

> Note    
> 프로퍼티가 항상 동일한 초기값을 사용하는 경우 초기화 구문 내에서 값을 설정하기보다 기본값을 제공하세요.
> 결과는 같지만 기본값은 프로퍼티의 초기화를 해당 선언과 더 밀접하게 연결합니다.
> 이를 통해 더 짧고 명확한 초기화가 가능하며 기본값에서 프로퍼티의 타입을 추론할 수 있습니다.
> 또한 기본값은 이 챕터 후반부에 설명된 대로 기본 초기화 및 초기화 구문 상속을 더 쉽게 활용할 수 있습니다.

#

프로퍼티가 선언되는 시점에 `temperature` 에 기본값을 제공하여 위의 `Fahrenheit` 구조체를 더 간단한 형식으로 작성할 수 있습니다.

~~~ swift
struct Fahrenheit {
    var temperature = 32.0
}
~~~

<br>

## 초기화 구문 사용자 정의 (Customizing Initialization)

다음 섹션에 설명된 대로 입력 파라미터 및 옵셔널 프로퍼티 타입을 사용하거나 초기화 중에 상수 프로퍼티를 할당하여 초기화 단계를 사용자 정의할 수 있습니다.

<br>

### 초기화 파라미터 (Initialization Parameters)

초기화 파라미터를 초기화 정의의 일부로 제공하여 초기화 단계를 사용자 정의하는 값의 타입과 이름을 정의할 수 있습니다.

초기화 파라미터는 함수 및 메서드 파라미터와 동일한 기능 및 구문을 갖습니다.

#

다음 예제는 섭씨 온도로 표시되는 온도를 저장하는 `Celsius` 구조체를 정의합니다.

`Celsius` 구조체는 다른 온도 체계에서의 값으로 구조체의 새로운 인스턴스를 초기화하기 위해 `init(fromFahrenheit:)` 와 `init(fromKelvin:)` 이라고 하는 2개의 사용자 정의 초기화 구문을 구현합니다.

~~~ swift
struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius is 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius is 0.0
~~~

첫번째 초기화 구문은 `fromFahrenheit` 의 인수 레이블과 `fahrenheit` 의 파라미터 이름을 가진 단일 초기화 파라미터를 가지고 있습니다.

두번째 초기화 구문은 `fromKelvin` 의 인수 레이블과 `kelvin` 의 파라미터 이름을 가진 단일 초기화 파라미터를 가지고 있습니다.

두 초기화 구문은 모두 단일 인수를 해당 섭씨 값으로 변환하고 `temperatureInCelsius` 라는 프로퍼티에 값을 저장합니다.

<br>

### 파라미터 이름 및 인수 레이블 (Parameter Names and Argument Labels)

함수와 메서드 파라미터와 마찬가지로 초기화 파라미터에는 초기화 구문의 본문 내에서 사용할 파라미터 이름과 초기화 호출 시 사용할 인수 레이블이 모두 있을 수 있습니다.

#

그러나 초기화 구문에는 함수 및 메서드와 달리 소괄호 앞에 식별 함수 이름이 없습니다.

따라서 초기화 구문 파라미터의 이름과 타입은 어떤 초기화 구문을 호출해야 하는지 식별하는데 특히 중요한 역할을 합니다.

이 때문에 Swift 는 사용자가 파라미터를 제공하지 않을 경우 초기화의 모든 파라미터에 대해 자동 인수 레이블을 제공합니다.

#

다음 예제는 `red`, `green`, `blue` 라는 3가지 상수 프로퍼티를 사용하여 `Color` 라는 구조체를 정의합니다.

이러한 프로퍼티는 색상의 빨간색, 초록색, 파란색 의 양을 나타내는 `0.0` 과 `1.0` 사이의 값을 저장합니다.

#

`Color` 는 빨간색, 초록색, 파란색의 구성 요소에 대해 적절하게 이름이 지정된 3가지 `Double` 타입 파라미터가 있는 초기화 구문을 제공합니다.

`Color` 는 3가지 색상 구성 요소 모두에 대해 동일한 값을 제공할 때 사용되는 `white` 파라미터를 가진 두번째 초기화 구문을 제공합니다.

~~~ swift
struct Color {
    let red, green, blue: Double
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
    init(white: Double) {
        red   = white
        green = white
        blue  = white
    }
}
~~~

#

두 초기화 구문은 각 초기화 구문 파라미터에 명명된 값을 제공하여 새로운 `Color` 인스턴스를 생성하는데 사용할 수 있습니다.

~~~ swift
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)
~~~

#

인수 레이블을 사용하지 않고 이러한 초기화 구문을 호출하는 것은 불가능합니다.

인수 레이블은 정의 되었다면 항상 초기화에서 사용되어야 하고 생략하면 컴파일 타임 에러가 발생합니다.

~~~ swift
let veryGreen = Color(0.0, 1.0, 0.0)
// this reports a compile-time error - argument labels are required
~~~

<br>

### 인수 레이블이 없는 초기화 구문 파라미터 (Initializer Parameters Without Augument Labels)

초기화 파라미터에 인수 레이블을 사용하지 않으려면 파라미터에 대한 명시적인 인수 레이블 대신 언더바 (`_`) 를 작성하여 기본 동작을 재정의 합니다.

#

다음은 섭씨 온도에 대한 `Double` 값으로 새로운 `Celsius` 인스턴스를 생성하기 위한 추가 초기화 구문이 포함된 [초기화 파라미터 (Initialization Parameters)]() 의 `Celsius` 예제의 확장된 버전입니다.

~~~ swift
struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
    init(_ celsius: Double) {
        temperatureInCelsius = celsius
    }
}
let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius is 37.0
~~~

`Celsius(37.0)` 초기화 구문 호출은 인수 레이블이 필요 없이 의도가 명확합니다.

따라서 이름 없는 `Double` 값을 제공하여 호출할 수 있도록 `init(_ celsius: Double)` 초기화 구문을 작성하는 것이 적절합니다.

<br>

### 옵셔널 프로퍼티 타입 (Optional Property Types)

사용자 정의 타입에 논리적으로 "값 없음" 이 허용되는 저장 프로퍼티가 있는 경우 (초기화 중에 해당 값을 설정할 수 없거나 나중에 "값 없음" 을 가질 수 있기 때문)

해당 프로퍼티를 옵셔널 타입 프로퍼티로 선언합니다.

옵셔널 타입의 프로퍼티 값은 `nil` 값으로 자동 초기화됩니다.

이는 프로퍼티가 초기화 중에 "아직 값 없음" 을 가진다는 의도를 나타냅니다.

#

다음 예제는 `response` 라는 옵셔널 `String` 프로퍼티를 가지는 `SurveyQuestion` 이라는 클래스를 정의합니다.

~~~ swift
class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
cheeseQuestion.ask()
// Prints "Do you like cheese?"
cheeseQuestion.response = "Yes, I do like cheese."
~~~

설문조사 질문에 대한 응답은 질문을 받을 때까지 알 수 없으므로 `response` 프로퍼티 타입은 `String?` 또는 "옵셔널 `String`" 타입으로 선언됩니다.

`SurveyQuestion` 의 새로운 인스턴스가 초기화 되면 "아직 문자열 없음" 을 의미하는 기본값 `nil` 이 자동으로 할당됩니다.

<br>

### 초기화 중 상수 프로퍼티 할당 (Assigning Constant Properties During Initialization)

초기화가 완료될 때까지 명확한 값으로 설정되는 한 초기화 중 언제든지 상수 프로퍼티에 값을 할당할 수 있습니다.

상수 프로퍼티에 값이 할당되면 더 이상 수정할 수 없습니다.

> Note    
> 클래스 인스턴스의 경우 상수 프로퍼티는 해당 프로퍼티를 도입한 클래스에 의해서만 초기화 중에 수정될 수 있습니다.
> 하위 클래스에서는 수정할 수 없습니다.

#

위의 `SurveyQuestion` 예제를 수정하여 `text` 프로퍼티에 대해 변수 프로퍼티가 아닌 상수 프로퍼티를 사용하여 `SurveyQuestion` 인스턴스가 생성된 후에는 질문이 변경되지 않음을 나타낼 수 있습니다.

`text` 프로퍼티가 이제 상수 이더라도 클래스의 초기화 구문 내에서 계속 설정할 수 있습니다.

~~~ swift
class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let beetsQuestion = SurveyQuestion(text: "How about beets?")
beetsQuestion.ask()
// Prints "How about beets?"
beetsQuestion.response = "I also like beets. (But not with cheese.)"
~~~

<br>

## 기본 초기화 구문 (Default Initializers)

Swift 는 모든 프로퍼티에 대한 기본값을 제공하고 최소한 하나의 초기화 구문을 제공하지 않는 모든 구조체 또는 클래스에 대해 기본 초기화 구문을 제공합니다.

기본 초기화 구문은 모든 프로퍼티가 기본값으로 설정된 새로운 인스턴스를 생성합니다.

#

이 예제는 쇼핑 리스트에 있는 항목의 이름, 수량 그리고 구매 상태를 캡슐화하는 `ShoppingListItem` 클래스를 정의합니다.

~~~ swift
class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()
~~~

`ShoppingListItem` 클래스의 모든 프로퍼티는 기본값을 가지고 있고 상위 클래스가 없는 기본 클래스이기 때문에 모든 프로퍼티가 기본값으로 설정된 새로운 인스턴스를 생성하()는 기본 초기화 구현을 자동으로 갖습니다.

(`name` 프로퍼티는 코드에서 값을 작성하지 않았지만 옵셔널 `String` 프로퍼티 이므로 자동으로 기본값 `nil` 을 받습니다.)

위의 예제는 `ShoppingListItem` 클래스의 기본 초기화를 사용하여 클래스의 새로운 인스턴스를 생성합니다.

`ShoppingListItem()` 으로 작성된 초기화 구문을 사용하고 클래스의 새로운 인스턴스를 `item` 이라는 변수에 할당합니다.

<br>

### 구조체 타입에 대한 멤버별 초기화 구문 (Memberwise Initializers for Structure Types)

구조체 타입은 자체 사용자 정의 초기화 구문을 정의하지 않는 경우 자동으로 멤버별 초기화 구문을 받습니다.

기본 초기화 구문과 다르게 구조체는 기본값을 가지지 않는 저장 프로퍼티가 있더라도 멤버별 초기화 구문을 받습니다.

#

멤버별 초기화 구문은 새로운 구조체 인스턴스의 멤버 프로퍼티를 초기화하는 간단한 방법입니다.

새로운 인스턴스의 프로퍼티에 대한 초기값은 이름으로 멤버별 초기화 구문으로 전달될 수 있습니다.

#

아래 예제는 `width` 와 `height` 라는 2가지 프로퍼티를 가진 `Size` 구조체를 정의합니다.

두 프로퍼티 모두 `0.0` 의 기본값을 할당하여 `Double` 타입으로 추론됩니다.

#

`Size` 구조체는 새로운 `Size` 인스턴스를 초기화는데 사용할 수 있는 멤버별 초기화 `init(width:height:)` 를 자동으로 받습니다.

~~~ swift
struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
~~~

#

멤버별 초기화 구문을 호출할 때 기본값을 가지는 모든 프로퍼티의 값을 생략할 수 있습니다.

위의 예제에서 `Size` 구조체는 `height` 와 `width` 프로퍼티 모두 기본값을 가지고 있습니다.

프로퍼티 중 하나 또는 둘다 생략할 수 있고 초기화 구문은 생략된 항목에 대해 기본값을 사용합니다.

~~~ swift
let zeroByTwo = Size(height: 2.0)
print(zeroByTwo.width, zeroByTwo.height)
// Prints "0.0 2.0"


let zeroByZero = Size()
print(zeroByZero.width, zeroByZero.height)
// Prints "0.0 0.0"
~~~

<br>

## 값 타입에 대한 초기화 구문 위임 (Initializer Delegation for Value Types)

초기화 구문은 다른 초기화 구문을 호출하여 인스턴스 초기화의 일부를 수행할 수 있습니다.

초기화 구문 위임 이라는 이 프로세스는 여러 초기화 구문에서 코드가 중복되는 것을 방지합니다.

#

초기화 구문 위임이 작동하는 방식과 허용되는 위임 형식에 대한 규칙은 값 타입과 클래스 타입에 따라 다릅니다.

값 타입(구조체 및 열거형) 은 상속을 지원하지 않으므로 초기화 구문 위임 프로세스는 자신이 제공하는 다른 초기화에만 위임할 수 있기 때문에 상대적으로 간단합니다.

그러나 클래스는 [상속 (Inheritance)]() 에 설명된 대로 다른 클래스에서 상속할 수 있습니다.

이는 클래스가 상속하는 모든 저장 프로퍼티에 초기화 중에 적절한 값이 할당되도록 보장하는 추가 책임이 있음을 의미합니다.

이러한 책임은 아래 [클래스 상속 및 초기화 (Class Inheritance and Initialization)]() 에 설명되어 있습니다.

#

값 타입의 경우 사용자 정의 초기화 구문을 작성할 때 동일한 값 타입의 다른 초기화 구문을 참조하기 위해 `self.init` 을 사용합니다.

초기화 구문 내에서만 `self.init` 을 호출할 수 있습니다.

#

값 타입에 대해 사용자 정의 초기화 구문을 정의하면 해당 타입에 대한 기본 초기화 구문 또는 구조체의 경우 멤버별 초기화 구문에 더이상 접근할 수 없습니다.

이 제약은 자동 초기화 구문을 사용하는 누군가가 더 복잡한 초기화 구문에서 제공하는 추가 필수 설정을 실수로 우회하는 것을 방지합니다.

> Note    
> 사용자 정의 값 타입을 기본 초기화 구문과 멤버별 초기화 구문 및 사용자 정의 초기화 구문으로 초기화 하려면 값 타입의 원래 구현의 일부가 아닌 확장에 사용자 정의 초기화 구문을 작성하세요.
> 자세한 내용은 [확장 (Extensions)]() 를 참조하세요.

#

다음의 예제는 기하학적 직사각형을 나타내는 사용자 정의 `Rect` 구조체를 정의합니다.

이 예제는 `Size` 와 `Point` 라는 2개의 지원 구조체가 필요하고 둘 다 모든 프로퍼티에 대해 `0.0` 의 기본값을 제공합니다.

~~~ swift
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
~~~

#

아래의 `Rect` 구조체를 기본 값 0으로 초기화된 `origin` 과 `size` 프로퍼티 값을 사용하거나 특정 원점과 크기를 제공하거나 특정 중심점과 크기를 제공하는 3가지 방법중 하나로 초기화할 수 있습니다.

이러한 초기화 옵션은 `Rect` 구조체 정의의 일부인 3개의 사용자 정의 초기화 구문으로 표시됩니다.

~~~ swift
struct Rect {
    var origin = Point()
    var size = Size()
    init() {}
    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
~~~

첫번째 `Rect` 초기화 구문인 `init()` 은 자체 사용자 정의 초기화 구문이 없는 경우 구조체가 수신했을 기본 초기화 구문과 기능적으로 동일합니다.

이 초기화 구문은 빈 중괄호 `{}` 로 표시된 빈 본문을 가집니다.

이 초기화 구문을 호출하면 `origin` 과 `size` 프로퍼티는 프로퍼티 정의에서 `Point(x: 0.0, y: 0.0)` 과 `Size(width: 0.0, height: 0.0)` 의 기본값으로 초기화되는 `Rect` 인스턴스를 반환합니다.

~~~ swift
let basicRect = Rect()
// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)
~~~

#

두번째 `Rect` 초기화 구문인 `init(origin:size:)` 은 자체 사용자 정의 초기화 구문이 없는 경우 구조체가 수신했을 때 멤버별 초기화 구문과 기능적으로 동일합니다.

이 초기화 구문은 단순히 `origin` 과 `size` 인수값을 적절한 저장 프로퍼티에 할당합니다.

~~~ swift
let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
    size: Size(width: 5.0, height: 5.0))
// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)
~~~

#

세번째 `Rect` 초기화 구문인 `init(center:size:)` 는 좀 더 복잡합니다.

`center` 포인트와 `size` 값을 기반으로 적절한 원점을 계산하는 것으로 시작합니다.

그런 다음 적절한 프로퍼티에 새로운 원점과 크기 값을 저장하는 `init(origin:size:)` 초기화 구문을 호출 (또는 위임) 합니다.

~~~ swift
let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
    size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
~~~

`init(center:size:)` 초기화 구문은 적절한 프로퍼티 자체에 `origin` 과 `size` 의 새로운 값을 할당했을 수 있습니다.

그러나 `init(center:size)` 초기화 구문이 해당 기능을 이미 정확하게 제공하는 기존 초기화를 활용하는 것이 더 편리하고 의도가 더 명확합니다.

> Note    
> `init()` 과 `init(origin:size:)` 초기화 구문을 직접 정의하지 않고 이 예제를 작성하는 다른 방법은 [확장 (Extensions)]() 을 참조하세요.

<br>

## 클래스 상속과 초기화 (Class Inheritance and Initialization)

클래스가 상위 클래스에서 상속하는 모든 프로퍼티를 포함하여 클래스의 모든 저장 프로퍼티에는 초기화 중에 초기 값이 할당되어야 합니다.

#

Swift 는 모든 저장 프로퍼티가 초기값을 받을 수 있도록 돕기 위해 클래스 타입에 대해 2가지 종류의 초기화 구문을 정의합니다.

이를 지정 초기화 구문과 편의 초기화 구문 이라고 합니다.

<br>

### 지정 초기화 구문과 편의 초기화 구문 (Designated Initializers and Convenience Initializers)

지정 초기화 구문은 클래스의 기본 초기화 구문입니다.

지정 초기화는 해당 클래스에 의해 도입된 모든 프로퍼티를 완전히 초기화하고 적절한 상위 클래스 초기화를 호출하여 초기화 프로세스를 상위 클래스까지 연결하여 계속합니다.

#

클래스에는 지정 초기화 구문이 거의 없는 경향이 있으며 클래스에 하나만 있는 경우가 매우 일반적입니다.

지정 초기화 구문은 초기화가 수행되고 초기화 프로세스가 상위 클래스 체인까지 계속되는 "funnel" 지점입니다.

#

모든 클래스는 적어도 하나의 지정 초기화 구문이 있어야 합니다.

어떤 경우에는 아래의 [자동 초기화 구문 상속 (Automatic Initializer Inheritance)]() 에 설명된 대로 상위 클래스에서 하나 이상의 지정 초기화 구문을 상속하여 이 요구사항을 충족합니다.

#

편의 초기화는 클래스에 대한 초기화 구문을 지원하는 보조 초기화 구문입니다.

지정 초기화의 파라미터 중 일부를 기본값으로 설정하여 편의 초기화와 동일한 클래스에서 지정 초기화를 호출하도록 편의 초기화를 정의할 수 있습니다.

특정 사용 케이스 또는 입력 값 타입에 대한 해당 클래스의 인스턴스를 생성하기 위해 편의 초기화를 정의할 수도 있습니다.

#

클래스에서 필요하지 않은 경우 편의 초기화를 제공할 필요가 없습니다.

일반적인 초기화 패턴에 대한 바로가기가 시간을 절약하거나 클래스 초기화 의도를 더 명확하게 만들 때마다 편의 초기화를 만듭니다.

<br>

### 지정 및 편의 초기화 구문 (Syntax for Designated and Convenience Initializers)

클래스에 대한 지정 초기화 구문은 값 타입에 대한 간단한 초기화 구문과 동일한 방식으로 작성됩니다.

~~~ swift
init(<#parameters#>) {
   <#statements#>
}
~~~

#

편의 초기화 구문은 동일한 스타일로 작성되지만 `init` 키워드 앞에 `convenience` 수정자가 작성되고 공백으로 구분됩니다.

~~~ swift
convenience init(<#parameters#>) {
   <#statements#>
}
~~~

<br>

### 클래스 타입에 대한 초기화 위임 (Initializer Delegation for Class Types)

지정 초기화 구문과 편의 초기화 구문 사이의 관계를 단순화하기 위해 Swift 는 초기화 사이의 위임 호출에 대해 다음 3가지 규칙을 적용합니다.

**규칙 1**

- 지정 초기화 구문은 직계 상위 클래스의 지정 초기화 구문을 호출해야 합니다.

**규칙 2**

- 편의 초기화 구문은 동일한 클래스에서 다른 초기화를 호출해야 합니다.

**규칙 3**

- 편의 초기화 구문은 궁극적으로 지정 초기화 구문을 호출해야 합니다.

#

이것을 기억하는 간단한 방법은 다음과 같습니다.

- 지정 초기화 구문은 항상 위를 위임해야 합니다.

- 편의 초기화 구문은 항상 옆에 걸쳐 위임해야 합니다.

#

이러한 규칙은 아래의 그림에 설명되어 있습니다.

<img width="500" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/93ec426d-33a0-4310-9434-776f1fa63b90">

여기서 상위 클래스에는 하나의 지정 초기화와 2개의 편의 초기화가 있습니다.

하나의 편의 초기화는 또 다른 편의 초기화를 호출하고 이는 차례로 단일 지정 초기화를 호출합니다.

이는 위츼 규칙2 와 규칙3 을 만족합니다.

상위 클래스 자체에는 추가 상위 클래스가 없으므로 규칙1 이 적용되지 않습니다.

#

이 그림의 하위 클래스에는 2개의 지정 초기화와 하나의 편의 초기화가 있습니다.

편의 초기화는 동일한 클래스의 다른 초기화만 호출할 수 있으므로 2개의 지정 초기화 중 하나를 호출해야 합니다.

이는 위의 규칙2 와 3을 만족합니다.

위의 규칙1 을 충족하려면 2개의 지정 초기화 모두 상위 클래스에서 단일 지정 초기화를 호출해야 합니다.

> Note    
> 이러한 규칙은 클래스의 사용자가 각 클래스의 인스턴스를 생성하는 방법에 영향을 주지 않습니다.
> 위 다이어그램의 모든 초기화 구문은 자신이 속한 클래스의 완전히 초기화된 인스턴스를 만드는데 사용할 수 있습니다.
> 규칙은 클래스의 초기화 구현을 작성하는 방법에만 영향을 미칩니다.

#

아래 그림은 4개의 클래스에 대한 더 복잡한 클래스 계층 구조를 보여줍니다.

이 계층 구조의 지정 초기화 구문이 클래스 초기화를 위한 "funnel" 지점 역할을 하여 체인에 있는 클래스 간의 상호 관계를 단순화하는 방법을 보여줍니다.

<img width="500" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/fa11e073-af72-44a3-a7a7-df6ac1f1b1fc">

<br>

### 2단계 초기화 (Two-Phase Initialization)

Swift 의 클래스 초기화는 2단계 프로세스 입니다.

첫번째 단계에서는 각 저장 프로퍼티가 해당 프로퍼티를 도입한 클래스에 의해 초기값이 할당됩니다.

모든 저장 프로퍼티의 초기 상태가 결정되면 두번째 단계가 시작되고 각 클래스에는 새로운 인스턴스를 사용할 준비가 된 것으로 간주되기 전에 저장 프로퍼티를 추가로 사용자 정의할 수 있는 기회가 제공됩니다.

#

2단계 초기화 프로세스를 사용하면 초기화가 안전하게 이루어지며 클래스 계층 구조의 각 클래스에 완전한 유연성이 제공됩니다.

2단계 초기화는 프로퍼티 값이 초기화되기 전에 접근되는 것을 방지하고 프로퍼티 값이 예기치 않게 다른 초기화에 의해 다른 값으로 설정되는 것을 방지합니다.

> Note    
> Swift 의 2단계 초기화 프로세스는 Objective-C 의 초기화와 유사합니다.
> 주요 차이점은 1단계에서 Objective-C 는 모든 프로퍼티에 0 또는 null 값 (`0` 또는 `nil`) 을 할당한다는 것입니다.
> Swift 의 초기화 흐름은 사용자 정의 초기값을 설정할 수 있고 `0` 또는 `nil` 이 유효한 기본값이 아닌 타입에 대처할 수 있다는 점에서 더 유연합니다.

#

Swift 의 컴파일러는 2단계 초기화가 에러없이 완료되었는지 확인하기 위해 4가지 유용한 안전 검사를 수행합니다.

**안전 점검 1**

- 지정 초기화는 클래스에 의해 도입된 모든 프로퍼티가 상위 클래스 초기화에 위임되기 전에 초기화가 되도록 보장해야 합니다.

위에서 언급했듯이 객체의 메모리는 모든 저장 프로퍼티의 초기 상태가 알려진 후에만 완전히 초기화된 것으로 간주됩니다.

이 규칙을 충족하려면 지정 초기화는 체인을 전달하기 전에 모든 자체 프로퍼티가 초기화 되었는지 확인해야 합니다.

**안전 점검 2**

- 지정 초기화는 상속된 프로퍼티에 값을 할당하기 전에 상위 클래스 초기화에 위임해야 합니다. 그렇지 않으면 지정 초기화가 할당한 새 값은 자체 초기화의 일부로 상위 클래스에 의해 덮어 쓰여집니다.

**안전 점검 3**

- 편의 초기화는 모든 프로퍼티 (동일한 클래스에 의해 정의된 프로퍼티 포함) 에 값을 할당하기 전에 다른 초기화에 위임해야 합니다. 그렇지 않으면 편의 초기화가 할당한 새 값은 자체 클래스의 지정 초기화로 덮어 쓰여집니다. 

**안전 점검 4**

- 초기화는 첫번째 초기화 단계가 완료될 때까지 인스턴스 메서드를 호출하거나 인스턴스 프로퍼티값을 읽거나 `self` 값을 참조할 수 없습니다.

#

클래스 인스턴스는 첫번째 단계가 끝날 때까지 완전히 유효하지 않습니다.

첫번째 단계가 끝날 때 클래스 인스턴스가 유요한 것으로 판단된 후에만 프로퍼티에만 접근할 수 있고 메서드만 호출할 수 있습니다.

#

위의 4가지 안전 점검을 기반으로 2단계 초기화가 수행되는 방식은 아래와 같습니다.

**1 단계**

- 지정 또는 편의 초기화가 클래스에서 호출됩니다.

- 해당 클래스의 새로운 인스턴스에 대한 메모리가 할당됩니다. 메모리가 아직 초기화 되지 않았습니다.

- 해당 클래스의 지정 초기화는 클래스에 의해 도입된 모든 저장 프로퍼티가 값을 가지고 있는지 확인합니다. 이제 이러한 저장 프로퍼티에 대한 메모리가 초기화됩니다.

- 지정 초기화는 자신의 저장 프로퍼티에 대해 동일한 작업을 수행하기 위해 상위 클래스 초기화에 전달됩니다.

- 이것은 체인의 최상위에 도달할 때까지 클래스 상속 체인을 계속 진행합니다.

- 최상위 체인에 도달하고 체인의 마지막 클래스가 모든 저장 프로퍼티에 값이 있음을 확인하면 인스턴스의 메모리가 완전히 초기화된 것으로 간주되어 1단계가 완료됩니다.

#

**2 단계**

- 체인의 최상위에서 아래로 내려가면 체인의 각 지정 초기화에는 인스턴스를 추가로 사용자 정의할 수 있는 옵션이 있습니다. 초기화는 이제 해당 `self` 프로퍼티에 접근하여 수정하고 인스턴스 메서드를 호출하는 등의 작업을 수행할 수 있습니다.

- 마지막으로 체인의 모든 편의 초기화에는 인스턴스를 사용자 정의하고 `self` 로 작업할 수 있는 옵션이 있습니다.

#

다음은 1단계에서 가상의 하위 클래스 및 상위 클래스에 대한 초기화 호출을 찾는 방법을 나타냅니다.

<img width="500" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/efd3155b-462b-44b1-95fc-46f305a81daf">

이 예제에서 초기화는 하위 클래스의 편의 초기화 호출로 시작됩니다.

이 편의 초기화는 아직 어떤 프로퍼티도 수정할 수 없습니다.

동일한 클래스의 지정 초기화에 위임합니다.

#

지정 초기화는 안전 점검1 에 따라 하위 클래스의 모든 프로퍼티에 값이 있는지 확인합니다.

그런 다음 상위 클래스에서 지정 초기화를 호출하여 체인의 초기화를 계속합니다.

#

상위 클래스의 지정 초기화는 모든 상위 클래스 프로퍼티에 값이 있는지 확인합니다.

초기화 할 추가 상위 클래스가 없으므로 추가 위임이 필요하지 않습니다.

#

상위 클래스의 모든 프로퍼티가 초기값을 갖게 되면 해당 메모리는 완전히 초기화된 것으로 간주되어 1단계가 완료됩니다.

#

다음은 2단계에서 동일한 초기화 호출을 찾는 방법을 나타냅니다.

<img width="500" src="https://github.com/Developer-Nova/Swift-Documentation/assets/123448121/f0af4079-c4f2-4b22-a7b4-946d7d9ee10e">

이제 상위 클래스의 지정 초기화는 인스턴스를 추가로 사용자 정의할 수 있는 기회 (필수는 아님) 를 갖습니다.

#

상위 클래스의 지정 초기화가 완료되면 하위 클래스의 저정 초기화는 추가적인 사용자 정의를 수행할 수 있습니다.

#

마지막으로 하위 클래스의 지정 초기화가 완료되면 원래 호출되었던 편의 초기화가 추가 사용자 정의를 수행할 수 있습니다.

<br>

### 초기화 상속 및 재정의 (Initializer Inheritance and Overriding)

Objective-C 의 하위 클래스와 달리 Swift 하위 클래스는 기본적으로 상위 클래스 초기화 구문을 상속하지 않습니다.

Swift 의 접근 방식은 상위 클래스의 간단한 초기화가 보다 특수화된 하위 클래스에 의해 상속되고 완전히 또는 올바르게 초기화되지 않은 하위 클래스의 새로운 인스턴스를 생성하는데 사용되는 상황을 방지합니다.

> Note    
> 상위 클래스 초기화는 특정 상황에서 상속되지만 안전하고 적절한 경우에만 상속됩니다.
> 자세한 내용은 아래의 [자동 초기화 상속 (Automatic Initializer Inheritance)]() 을 참조하세요.

#

사용자 정의 하위 클래스가 상위 클래스와 동일한 초기화 구문 중 하나 이상을 제공하도록 하려면 하위 클래스 내에서 해당 초기화 구문의 사용자 정의 구현을 제공할 수 있습니다.

#

상위 클래스 지정 초기화 구문과 일치하는 하위 클래스 초기화 구문을 작성하면 해당 지정 초기화 구문의 재정의를 효과적으로 제공하는 것입니다.

따라서 하위 클래스의 초기화 정의 전에 `override` 수정자를 작성해야 합니다.

[기본 초기화 (Default Initializers)]() 에 설명된 대로 자동으로 제공되는 기본 초기화를 재정의하는 경우에도 마찬가지입니다.

#

재정의된 프로퍼티, 메서드 또는 서브 스크립트와 마찬가지로 `override` 수정자가 있으면 Swift 는 상위 클래스에 재정의 할 지정 초기화가 일치하는지 확인하고 재정의 할 초기화의 파라미터가 의도한대로 지정되었는지 확인합니다.

> Note    
> 하위 클래스의 초기화 구현이 편의 초기화인 경우에도 상위 클래스 지정 초기화를 재정의할 때 항상 `override` 수정자를 작성합니다.

#

반대로 상위 클래스의 편의 초기화와 일치하는 하위 클래스 초기화를 작성하는 경우 위의 [클래스 타입에 대한 초기화 위임 (Initializer Delegation for Class Types)]() 에 설명된 규칙에 따라 해당 상위 클래스 편의 초기화는 하위 클래스에서 직접 호출할 수 없습니다.

따라서 하위 클래스는 상위 클래스 초기화의 재정의를 제공하지 않습니다.

결과적으로 상위 클래스 편의 초기화의 일치하는 구현을 제공할 때 `override` 수정자를 작성하지 않습니다.

#

아래 예제는 `Vehicle` 이라는 기본 클래스를 정의합니다.

이 기본 클래스는 기본 `Int` 값 `0` 을 가진 `numberOfWheels` 라는 저장 프로퍼티를 선언합니다.

`numberOfWheels` 프로퍼티는 차량의 특성에 대한 설명하는 `String` 을 생성하기 위해 호출되는 `description` 이라는 계산 프로퍼티에 의해 사용됩니다.

~~~ swift
class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return "\(numberOfWheels) wheel(s)"
    }
}
~~~







































***

### ⬅️ [Inheritance](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/13.Inheritance.md)

### ➡️ [Deinitialization](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/15.Deinitialization.md)
