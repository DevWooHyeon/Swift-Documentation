# Optional Chaining (옵셔널 체이닝)

언래핑 없이 옵셔널 값의 멤버에 접근합니다.

옵셔널 체이닝은 현재 `nil` 일 수 있는 옵셔널인 프로퍼티, 메서드 및 서브 스크립트를 조회하고 호출하는 프로세스입니다.

옵셔널에 값이 포함되어 있으면 프로퍼티, 메서드 또는 서브 스크립트는 호출에 성공합니다.

옵셔널이 `nil` 이면 프로퍼티, 메서드 또는 서브 스크립트 호출은 `nil` 을 반환합니다.

여러 쿼리를 함께 연결할 수 있으며 체인의 어느 부분이라도 `nil` 이면 전체 체인은 정상적으로 실패합니다.

> Note    
> Swift 의 옵셔널 체이닝은 Objective-C 의 메시징 `nil` 과 유사하지만 모든 타입에 대해 동작하고 성공 또는 실패 여부를 확인할 수 있는 방식입니다.

<br>

## 강제 언래핑에 대한 대안으로서의 옵셔널 체이닝 (Optional Chaining as an Alternative to Forced Unwrapping)

프로퍼티, 메서드 또는 서브 스크립트를 호출하려는 옵셔널 값 뒤에 물음표 (`?`) 를 배치하여 옵셔널 체이닝을 지정합니다.

이것은 해당 값을 강제 언래핑 하기 위해 옵셔널 값 뒤에 느낌표 (`!`) 를 배치하는 것과 유사합니다.

이것의 주요 차이점은 옵셔널이 `nil` 이면 옵셔널 체이닝이 정상적으로 실패하는 반면 옵셔널이 `nil` 이면 강제 언래핑은 런타임 에러를 발생시킨다는 것입니다.

#

옵셔널 체이닝은 `nil` 값에 대해 호출될 수 있다는 사실을 반영하기 위해 옵셔널 체이닝 호출의 결과는 쿼리하는 프로퍼티, 메서드 또는 서브 스크립트가 옵셔널 값이 아닌 값을 반환하는 경우에도 항상 옵셔널 값으로 반환합니다.

이 옵셔널 반환값을 사용하여 옵셔널 체이닝 호출이 성공했는지 (반환된 옵셔널 값에 값이 포함되어 있음) 또는 실패했는지 (반환된 옵셔널 값은 `nil`) 여부를 확인할 수 있습니다.

#

특히 옵셔널 체이닝 호출의 결과는 예상 반환 값과 동일한 타입이지만 옵셔널로 래핑됩니다.

일반적으로 `Int` 를 반환하는 프로퍼티는 옵셔널 체이닝을 통해 접근할 때 `Int?` 를 반환합니다.

#

다음 여러 코드 조각은 옵셔널 체이닝이 강제 언래핑과 어떻게 다른지 보여주고 성공 여부를 확인할 수 있도록 해줍니다.

먼저 `Person` 과 `Residence` 라는 2개의 클래스를 정의합니다.

~~~ swift
class Person {
    var residence: Residence?
}

class Residence {
    var numberOfRooms = 1
}
~~~

`Residence` 인스턴스는 `numberOfRooms` 라는 단일 `Int` 프로퍼티가 있으며 기본값은 `1` 입니다.

`Person` 인스턴스는 `Residence?` 타입의 옵셔널 프로퍼티 `residence` 가 있습니다.

#

새로운 `Person` 인스턴스를 생성하는 경우 해당 `residence` 프로퍼티는 옵셔널이므로 기본적으로 `nil` 로 초기화 됩니다.

아래의 코드에서 `jhon` 은 `residence` 프로퍼티에 `nil` 값을 가지고 있습니다.

~~~ swift
let john = Person()
~~~

#

값을 강제 언래핑하기 위해 `residence` 뒤에 느낌표를 배치하여 이 사람의 `residence` 에 `numberOfRooms` 프로퍼티에 접근하려고 하면 언래핑 할 `residence` 값이 없기 때문에 런타임 에러가 발생합니다.

~~~ swift
let roomCount = john.residence!.numberOfRooms
// this triggers a runtime error
~~~

`john.residence` 가 `nil` 값이 아니고 `roomCount` 에 방의 적절한 숫자를 포함한 `Int` 값으로 설정하면 위의 코드는 정상적으로 동작합니다.

그러나 `residence` 가 `nil` 이면 이 코드는 항상 런타임 에러를 발생시킵니다.

#

옵셔널 체이닝은 `numberOfRooms` 값에 접근하는 대체 방법을 제공합니다.

옵셔널 체이닝을 사용하려면 느낌표 대신 물음표를 사용합니다.

~~~ swift
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// Prints "Unable to retrieve the number of rooms."
~~~

이것은 Swift 에게 옵셔널 `residence` 프로퍼티를 "체인" 하고 `residence` 가 존재하는 경우 `numberOfRooms` 값을 조회하도록 지시합니다.

#

`numberOfRooms` 에 접근하기 위한 시도는 실패할 가능성이 있으므로 옵셔널 체이닝 시도는 `Int?` 타입의 값 또는 "옵셔널 `Int`" 의 값을 반환합니다.

위의 예제에서와 같이 `residence` 가 `nil` 인 경우 `numberOfRooms` 에 접근할 수 없다는 사실을 반영하기 위해 옵셔널 `Int` 는 `nil` 이 됩니다.

옵셔널 `Int` 는 옵셔널 바인딩을 통해 접근되어 정수를 언래핑하고 옵셔널이 아닌 값을 `roomCount` 상수에 할당합니다.

#

이는 `numberOfRooms` 가 옵셔널 `Int` 가 아닌 경우에도 마찬가지 입니다.

옵셔널 체이닝을 통해 쿼리된다는 사실은 `numberOfRooms` 에 대한 호출이 항상 `Int` 대신 `Int?` 를 반환한다는 것을 의미합니다.

#

`Residence` 인스턴스를 `john.residence` 에 할당하여 더 이상 `nil` 값을 가지지 않도록 할 수 있습니다.

~~~ swift
john.residence = Residence()
~~~

이제 `john.residence` 가 `nil` 이 아닌 실제 `Residence` 인스턴스를 포함합니다.

이전 처럼 동일한 옵셔널 체이닝을 사용하여 `numberOfRooms` 에 접근하려고 하면 `numberOfRooms` 의 기본값 `1` 이 포함된 `Int?` 를 반환합니다.

~~~ swift
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// Prints "John's residence has 1 room(s)."
~~~

<br>

## 옵셔널 체이닝을 위한 모델 클래스 정의 (Defining Model Classes for Optional Chaining)

하나 이상의 깊이의 프러퍼티, 메서드 그리고 서브 스크립트에 대한 호출과 함께 옵셔널 체이닝을 사용할 수 있습니다.

이를 통해 상호 연관된 타입의 복잡한 모델 내에서 하위 프로퍼티로 내려갈 수 있으며 해당 하위 프로퍼티의 프로퍼티, 메서드 그리고 서브 스크립트에 접근할 수 있는지 여부를 확인할 수 있습니다.

#

아래의 코드는 여러 단계 옵셔널 체이닝의 예를 포함하여 여러 후속 예제에서 사용할 4개의 모델 클래스를 정의합니다.

이 클래스는 관련 프로퍼티, 메서드 그리고 서브 스크립트를 가지는 `Room` 과 `Address` 클래스를 추가하여 위의 `Person` 과 `Residence` 모델을 확장합니다.

#

`Person` 클래스는 이전과 같은 방식으로 정의됩니다.

~~~ swift
class Person {
    var residence: Residence?
}
~~~

#

`Residence` 클래스는 이전보다 더 복잡해졌습니다.

이번에는 `Residence` 클래스가 `[Room]` 타입의 빈 배열로 초기화되는 `rooms` 라는 변수 프로퍼티를 정의합니다.

~~~ swift
class Residence {
    var rooms: [Room] = []
    var numberOfRooms: Int {
        return rooms.count
    }
    subscript(i: Int) -> Room {
        get {
            return rooms[i]
        }
        set {
            rooms[i] = newValue
        }
    }
    func printNumberOfRooms() {
        print("The number of rooms is \(numberOfRooms)")
    }
    var address: Address?
}
~~~

이 `Residence` 버전에서는 `Room` 인스턴스 배열을 저장하므로 `numberOfRooms` 프로퍼티는 저장 프로퍼티가 아닌 계산 프로퍼티로 구현됩니다.

계산 프로퍼티 `numberOfRooms` 는 단순히 `rooms` 배열에서 `count` 프로퍼티의 값을 반환합니다.

#

`rooms` 배열에 접근하는 짧은 구문을 위해 `Residence` 는 `rooms` 배열의 요청된 인덱스에 있는 공간에 대한 접근을 제공하는 읽기-쓰기 서브 스크립트를 제공합니다.

#

이 `Residence` 는 거주지의 방 갯수를 간단히 출력하는 `printNumberOfRooms` 라는 메서드도 제공합니다.

#

마지막으로 `Residence` 는 `Address?` 타입을 가지는 `address` 라는 옵셔널 프로퍼티를 정의합니다.

이 프로퍼티의 `Address` 클래스 타입은 아래에 정의되어 있습니다.

#

`rooms` 배열에 사용되는 `Room` 클래스는 `name` 이라는 프로퍼티와 해당 프로퍼티를 적절한 방 이름으로 설정하는 초기화가 있는 간단한 클래스 입니다.

~~~ swift
class Room {
    let name: String
    init(name: String) { self.name = name }
}
~~~

#

이 모델의 마지막 클래스는 `Address` 입니다.

이 클래스에는 `String?` 타입의 3가지 옵셔널 프로퍼티가 있습니다.

`buildingName` 과 `buildingNumber` 인 첫번째, 두번째 프로퍼티는 주소의 일부로 특정 건물을 식별하는 대체 방법입니다.

세번째 프로퍼티인 `street` 은 해당 주소의 거리 이름을 지정하는데 사용됩니다.

~~~ swift
class Address {
    var buildingName: String?
    var buildingNumber: String?
    var street: String?
    func buildingIdentifier() -> String? {
        if let buildingNumber = buildingNumber, let street = street {
            return "\(buildingNumber) \(street)"
        } else if buildingName != nil {
            return buildingName
        } else {
            return nil
        }
    }
}
~~~

또한 `Address` 클래스는 반환 타입이 `String?` 인 `buildingIdentifier()` 라는 메서드도 제공합니다.

이 메서드는 주소의 프로퍼티를 확인하고 값이 있는 경우 `buildingName` 을 반환하거나 둘다 값이 있는 경우 `street` 과 연결된 `buildingNumber` 를 반환하고 값이 없으면 `nil` 을 반환합니다.

<br>

## 옵셔널 체이닝을 통한 프로퍼티 접근 (Accessing Properties Through Optional Chaining)

[강제 언래핑에 대한 대안으로서의 옵셔널 체이닝 (Optional Chaining as an Alternative to Forced Unwrapping)]() 에서 설명한 대로 옵셔널 체이닝을 사용하여 옵셔널 값의 프로퍼티에 접근하고 해당 프로퍼티 접근이 성공적인지 확인할 수 있습니다.

#

위에 정의된 클래스를 사용하여 새로운 `Person` 인스턴스를 생성하고 이전과 같이 `numberOfRooms` 프로퍼티에 접근합니다.

~~~ swift
let john = Person()
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// Prints "Unable to retrieve the number of rooms."
~~~

`john.residence` 는 `nil` 이기 때문에 옵셔널 체이닝은 이전과 같은 방식으로 실패합니다.

#

옵셔널 체이닝을 통해 프로퍼티의 값을 설정하려고 시도할 수 있습니다.

~~~ swift
let someAddress = Address()
someAddress.buildingNumber = "29"
someAddress.street = "Acacia Road"
john.residence?.address = someAddress
~~~

이 예제에서 `john.residence` 가 `nil` 이기 때문에 `john.residence` 의 `address` 프로퍼티를 설정하려는 시도가 실패합니다.

#

할당은 옵셔널 체이닝의 일부입니다.

즉 연산자 `=` 오른쪽에 있는 코드는 평가되지 않습니다.

이전 예제에서 상수에 접근해도 아무런 영향이 없기 때문에 `someAddress` 가 평가되지 않는다는 것을 쉽게 알 수 없습니다.

아래의 목록은 동일한 할당을 수행하지만 주소를 생성하기 위해 함수를 사용합니다.

이 함수는 값을 반환하기 전에 "Function was called" 를 출력하므로 `=` 연산자의 오른쪽이 평가되었는지 확인할 수 있습니다.

~~~ swift
func createAddress() -> Address {
    print("Function was called.")

    let someAddress = Address()
    someAddress.buildingNumber = "29"
    someAddress.street = "Acacia Road"

    return someAddress
}
john.residence?.address = createAddress()
~~~

아무것도 출력되지 않기 때문에 `createAddress()` 함수가 호출되지 않았음을 알 수 있습니다.

<br>

## 옵셔널 체이닝을 통한 메서드 호출 (Calling Methods Through Optional Chaining)

옵셔널 체이닝을 사용하여 옵셔널 값에 대한 메서드를 호출하고 해당 메서드 호출이 성공하는지 확인할 수 있습니다.

해당 메서드가 반환값을 정의하지 않는 경우에도 이 작업을 수행할 수 있습니다.

#

`Residence` 클래스의 `printNumberOfRooms()` 메서드는 `numberOfRooms` 의 현재값을 출력합니다.

메서드는 아래와 같습니다.

~~~ swift
func printNumberOfRooms() {
    print("The number of rooms is \(numberOfRooms)")
}
~~~

이 메서드는 반환 타입을 지정하지 않습니다.

그러나 [반환값이 없는 함수 (Functions Without Return Values)]() 에 설명된 대로 반환 타입이 없는 함수와 메서드에는 암시적 반환 타입 `Void` 가 있습니다.

이것은 `()` 의 값 또는 빈 튜플을 반환한다는 의미입니다.

#

옵셔널 체이닝을 사용하여 옵셔널 값에 대해 이 메서드를 호출하는 경우 반환값은 항상 옵셔널 타입이기 때문에 메서드의 반환 타입은 `Void` 가 아닌 `Void?` 가 됩니다.

이를 통해 메서드 자체가 반환값을 정의하지 않더라도 `if` 문을 사용하여 `printNumberOfRooms()` 메서드 호출이 가능한지 여부를 확인할 수 있습니다.

`printNumberOfRooms()` 호출의 반환값을 `nil` 과 비교하여 메서드 호출이 성공했는지 확인합니다.

~~~ swift
if john.residence?.printNumberOfRooms() != nil {
    print("It was possible to print the number of rooms.")
} else {
    print("It was not possible to print the number of rooms.")
}
// Prints "It was not possible to print the number of rooms."
~~~

#

옵셔널 체이닝을 통해 프로퍼티를 설정하려는 경우에도 마찬가지입니다.

[옵셔널 체이닝을 통한 프로퍼티 접근 (Accessing Properties Through Optional Chaining)]() 에서 위의 예제는 `residence` 프로퍼티가 `nil` 임에도 불구하고 `john.residence` 에 대한 `address` 값을 설정하려고 시도합니다.

옵셔널 체이닝을 통해 프로퍼티를 설정하는 모든 시도는 `nil` 과 비교하여 프로퍼티에 값이 성공적으로 설정되었는지 확인할 수 있는 `Void?` 타입의 값을 반환합니다.

~~~ swift
if (john.residence?.address = someAddress) != nil {
    print("It was possible to set the address.")
} else {
    print("It was not possible to set the address.")
}
// Prints "It was not possible to set the address."
~~~

<br>

## 옵셔널 체이닝을 통한 서브 스크립트 접근 (Accessing Subscripts Through Optional Chaining)

옵셔널 체이닝을 사용하여 옵셔널 값의 서브 스크립트에서 값을 검색 및 설정하고 해당 서브 스크립트 호출이 성공했는지 확인할 수 있습니다.

> Note    
> 옵셔널 체이닝을 통해 옵셔널 값의 서브 스크립트에 접근할 때 물음표를 서브 스크립트의 대괄호 뒤가 아닌 앞에 배치합니다.
> 옵셔널 체이닝 물음표는 항상 옵셔널 표현식 부분의 바로 뒤에 위치합니다.

#

아래의 예제는 `Residence` 클래스에 정의된 서브 스크립트를 사용하여 `john.residence` 프로퍼티의 `rooms` 배열의 첫번째 방 이름을 검색하려고 시도합니다.

현재 `john.residence` 는 `nil` 이기 때문에 서브 스크립트 호출이 실패합니다.

~~~ swift
if let firstRoomName = john.residence?[0].name {
    print("The first room name is \(firstRoomName).")
} else {
    print("Unable to retrieve the first room name.")
}
// Prints "Unable to retrieve the first room name."
~~~

서브 스크립트 호출에서 옵셔널 체이닝 물음표는 `john.residence` 가 옵셔널 체이닝이 시도되는 옵셔널 값이기 때문에 `john.residence` 뒤와 대괄호 앞에 배치됩니다.

#

마찬가지로 옵셔널 체이닝을 사용하여 서브 스크립트를 통해 새로운 값을 설정할 수 있습니다.

~~~ swift
john.residence?[0] = Room(name: "Bathroom")
~~~

`residence` 가 현재 `nil` 이기 때문에 서브 스크립트 설정 시도는 실패합니다.

#

`rooms` 배열에 하나 이상의 `Room` 인스턴스가 있는 실제 `Residence` 인스턴스를 생성하고 `john.residence` 에 할당하는 경우 `Residence` 서브 스크립트를 사용하여 옵셔널 체이닝을 통해 `rooms` 배열의 실제 항목에 접근할 수 있습니다.

~~~ swift
let johnsHouse = Residence()
johnsHouse.rooms.append(Room(name: "Living Room"))
johnsHouse.rooms.append(Room(name: "Kitchen"))
john.residence = johnsHouse

if let firstRoomName = john.residence?[0].name {
    print("The first room name is \(firstRoomName).")
} else {
    print("Unable to retrieve the first room name.")
}
// Prints "The first room name is Living Room."
~~~

<br>

### 옵셔널 타입의 서브 스크립트 접근 (Accessing Subscripts of Optional Type)

서브 스크립트가 Swift 의 `Dictionary` 타입의 키 하위 서브 스크립트와 같이 옵셔널 타입의 값을 반환하는 경우 하위 서브 스크립트의 닫는 대괄호 뒤에 물음표를 배치하여 옵셔널 반환값을 연결합니다.

~~~ swift
var testScores = ["Dave": [86, 82, 84], "Bev": [79, 94, 81]]
testScores["Dave"]?[0] = 91
testScores["Bev"]?[0] += 1
testScores["Brian"]?[0] = 72
// the "Dave" array is now [91, 82, 84] and the "Bev" array is now [80, 94, 81]
~~~

위의 예제는 `String` 키를 `Int` 값 배열에 매핑하는 2개의 키-값 쌍이 포함된 `testScores` 라는 딕셔너리를 정의합니다.

이 예제에서는 옵셔널 체이닝을 사용하여 `"Dave"` 배열의 첫번째 항목에 `91` 을 설정하고 `"Bev"` 배열의 첫번째 항목에 `1` 을 더하고 `"Brian"` 배열의 첫번째 항목에 `72` 값을 설정하려고 합니다.

`testScores` 딕셔너리에 `"Dave"` 와 `"Bev"` 키가 포함되어 있기 때문에 첫번째 두번째 호출은 성공합니다.

`testScores` 딕셔너리에 `"Brian"` 키를 가지고 있지 않기 때문에 세번째 호출은 실패합니다.

<br>

## 여러 수준의 체인 연결 (Linking Multiple Levels of Chaining)













 







***

### ⬅️ [Deinitialization](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/15.Deinitialization.md)

### ➡️ [Error Handling](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/17.Error%20Handling.md)
