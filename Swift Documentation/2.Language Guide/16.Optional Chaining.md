# Optional Chaining (옵셔널 체이닝)

언래핑 없이 옵셔널 값의 멤버에 접근합니다.

옵셔널 체이닝은 현재 `nil` 일 수 있는 옵셔널인 프로퍼티, 메서드 및 서브 스크립트를 조회하고 호출하는 프로세스입니다.

옵셔널에 값이 포함되어 있으면 프로퍼티, 메서드 또는 서브 스크립트는 호출에 성공합니다.

옵셔널이 `nil` 이면 프로퍼티, 메서드 또는 서브 스크립트 호출은 `nil` 을 반환합니다.

여러 쿼리를 함께 연결할 수 있으며 체인의 어느 부분이라도 `nil` 이면 전체 체인은 정상적으로 실패합니다.

> Note    
> Swift 의 옵셔널 체이닝은 Objective-C 의 메시징 `nil` 과 유사하지만 모든 타입에 대해 동작하고 성공 또는 실패 여부를 확인할 수 있는 방식입니다.

<br>

## 강제 언래핑에 대한 대안으로서의 옵셔널 체이닝 (Optional Chaining as an Alternative to Forced Unwrapping)

프로퍼티, 메서드 또는 서브 스크립트를 호출하려는 옵셔널 값 뒤에 물음표 (`?`) 를 배치하여 옵셔널 체이닝을 지정합니다.

이것은 해당 값을 강제 언래핑 하기 위해 옵셔널 값 뒤에 느낌표 (`!`) 를 배치하는 것과 유사합니다.

이것의 주요 차이점은 옵셔널이 `nil` 이면 옵셔널 체이닝이 정상적으로 실패하는 반면 옵셔널이 `nil` 이면 강제 언래핑은 런타임 에러를 발생시킨다는 것입니다.

#

옵셔널 체이닝은 `nil` 값에 대해 호출될 수 있다는 사실을 반영하기 위해 옵셔널 체이닝 호출의 결과는 쿼리하는 프로퍼티, 메서드 또는 서브 스크립트가 옵셔널 값이 아닌 값을 반환하는 경우에도 항상 옵셔널 값으로 반환합니다.

이 옵셔널 반환값을 사용하여 옵셔널 체이닝 호출이 성공했는지 (반환된 옵셔널 값에 값이 포함되어 있음) 또는 실패했는지 (반환된 옵셔널 값은 `nil`) 여부를 확인할 수 있습니다.

#

특히 옵셔널 체이닝 호출의 결과는 예상 반환 값과 동일한 타입이지만 옵셔널로 래핑됩니다.

일반적으로 `Int` 를 반환하는 프로퍼티는 옵셔널 체이닝을 통해 접근할 때 `Int?` 를 반환합니다.

#

다음 여러 코드 조각은 옵셔널 체이닝이 강제 언래핑과 어떻게 다른지 보여주고 성공 여부를 확인할 수 있도록 해줍니다.

먼저 `Person` 과 `Residence` 라는 2개의 클래스를 정의합니다.

~~~ swift
class Person {
    var residence: Residence?
}

class Residence {
    var numberOfRooms = 1
}
~~~

`Residence` 인스턴스는 `numberOfRooms` 라는 단일 `Int` 프로퍼티가 있으며 기본값은 `1` 입니다.

`Person` 인스턴스는 `Residence?` 타입의 옵셔널 프로퍼티 `residence` 가 있습니다.

#

새로운 `Person` 인스턴스를 생성하는 경우 해당 `residence` 프로퍼티는 옵셔널이므로 기본적으로 `nil` 로 초기화 됩니다.

아래의 코드에서 `jhon` 은 `residence` 프로퍼티에 `nil` 값을 가지고 있습니다.

~~~ swift
let john = Person()
~~~

#

값을 강제 언래핑하기 위해 `residence` 뒤에 느낌표를 배치하여 이 사람의 `residence` 에 `numberOfRooms` 프로퍼티에 접근하려고 하면 언래핑 할 `residence` 값이 없기 때문에 런타임 에러가 발생합니다.

~~~ swift
let roomCount = john.residence!.numberOfRooms
// this triggers a runtime error
~~~

`john.residence` 가 `nil` 값이 아니고 `roomCount` 에 방의 적절한 숫자를 포함한 `Int` 값으로 설정하면 위의 코드는 정상적으로 동작합니다.

그러나 `residence` 가 `nil` 이면 이 코드는 항상 런타임 에러를 발생시킵니다.

#

옵셔널 체이닝은 `numberOfRooms` 값에 접근하는 대체 방법을 제공합니다.

옵셔널 체이닝을 사용하려면 느낌표 대신 물음표를 사용합니다.

~~~ swift
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// Prints "Unable to retrieve the number of rooms."
~~~

이것은 Swift 에게 옵셔널 `residence` 프로퍼티를 "체인" 하고 `residence` 가 존재하는 경우 `numberOfRooms` 값을 조회하도록 지시합니다.

#

`numberOfRooms` 에 접근하기 위한 시도는 실패할 가능성이 있으므로 옵셔널 체이닝 시도는 `Int?` 타입의 값 또는 "옵셔널 `Int`" 의 값을 반환합니다.

위의 예제에서와 같이 `residence` 가 `nil` 인 경우 `numberOfRooms` 에 접근할 수 없다는 사실을 반영하기 위해 옵셔널 `Int` 는 `nil` 이 됩니다.

옵셔널 `Int` 는 옵셔널 바인딩을 통해 접근되어 정수를 언래핑하고 옵셔널이 아닌 값을 `roomCount` 상수에 할당합니다.

#

이는 `numberOfRooms` 가 옵셔널 `Int` 가 아닌 경우에도 마찬가지 입니다.

옵셔널 체이닝을 통해 쿼리된다는 사실은 `numberOfRooms` 에 대한 호출이 항상 `Int` 대신 `Int?` 를 반환한다는 것을 의미합니다.

#

`Residence` 인스턴스를 `john.residence` 에 할당하여 더 이상 `nil` 값을 가지지 않도록 할 수 있습니다.

~~~ swift
john.residence = Residence()
~~~

이제 `john.residence` 가 `nil` 이 아닌 실제 `Residence` 인스턴스를 포함합니다.

이전 처럼 동일한 옵셔널 체이닝을 사용하여 `numberOfRooms` 에 접근하려고 하면 `numberOfRooms` 의 기본값 `1` 이 포함된 `Int?` 를 반환합니다.

~~~ swift
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// Prints "John's residence has 1 room(s)."
~~~

<br>

## 옵셔널 체이닝을 위한 모델 클래스 정의 (Defining Model Classes for Optional Chaining)
























***

### ⬅️ [Deinitialization](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/15.Deinitialization.md)

### ➡️ [Error Handling](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/17.Error%20Handling.md)
