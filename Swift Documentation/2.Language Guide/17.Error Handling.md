# Error Handling (에러 처리)

에러에 응답하고 복구합니다.

에러 처리는 프로그램의 에러 조건에 응답하고 복구하는 프로세스입니다.

Swift 는 런타임에 복구 가능한 에러 발생, 포착, 전파 및 조작에 대한 최고 수준의 지원을 제공합니다.

#

일부 작업은 항상 실행을 완료하거나 유용한 출력을 생성한다고 보장되지 않습니다.

옵셔널은 값이 없음을 나타내는데 사용되지만 작업이 실패할 경우 코드가 그에 따라 응답할 수 있도록 실패의 원인을 이해하는 것이 유용한 경우가 많습니다.

#

예를 들어 디스크의 파일에서 데이터를 읽고 처리하는 작업을 생각해 보세요.

지정된 경로에 파일이 존재하지 않거나, 파일에 읽기 권한이 없거나, 파일이 적절한 형식으로 인코딩 되지 않은 경우를 포함하여 작업이 실패할 수 있는 여러가지 방법이 있습니다.

이러한 다양한 상황을 구별하면 프로그램에서 일부 에러를 해결하고 해결할 수 없는 에러를 사용자에게 전달할 수 있습니다.

> Note    
> Swift 의 에러 처리는 Cocoa 및 Objective-C 의 `NSError` 클래스를 사용하는 에러 처리 패턴과 상호 운용됩니다.
> 이 클래스에 대한 자세한 내용은 [Swift 에서 Cocoa 에러 처리 (Handling Cocoa Errors in Swift)]() 를 참조하세요.

<br>

## 에러 표현과 던지기 (Representing and Throwing Errors)

Swift 에서 에러는 `Error` 프로토콜을 준수하는 타입의 값으로 표시됩니다.

이 빈 프로토콜은 에러 처리에 타입을 사용할 수 있음을 나타냅니다.

#

Swift 열거형은 관련된 에러 조건의 그룹을 모델링하는데 특히 적합하며 관련 값을 사용하여 에러의 성격에 대한 추가 정보를 전달할 수 있습니다.

예를 들어 게임 내에서 자동 판매기 작동 에러 조건을 표현한느 방법은 다음과 같습니다.

~~~ swift
enum VendingMachineError: Error {
    case invalidSelection
    case insufficientFunds(coinsNeeded: Int)
    case outOfStock
}
~~~

#

에러를 발생시키면 예상치 못한 일이 발생하여 정상적인 실행 흐름을 계속할 수 없음을 나타낼 수 있습니다.

`throw` 구문을 사용하여 에러를 발생시킵니다.

예를 들어 아래의 코드는 자동 판매기에서 5개의 추가 코인이 필요함을 나타내는 에러를 발생시킵니다.

~~~ swift
throw VendingMachineError.insufficientFunds(coinsNeeded: 5)
~~~

<br>

## 에러 처리 (Handling Errors)

에러가 발생하면 주변 코드의 일부분이 에러 처리를 담당해야 합니다.

예를 들어 문제를 수정하거나 대체 접근 방식을 시도하거나 사용자에게 에러를 알리는 등의 작업을 수행합니다.

#

Swift 에는 에러를 처리하는 4가지 방법이 있습니다.

함수에서 해당 함수를 호출하는 코드로 에러를 전파하거나 `do-catch` 문을 사용하여 에러를 처리하거나 에러를 옵셔널 값으로 처리하거나 에러가 발생하지 않을 것이라고 주장할 수 있습니다.

각 접근 방식은 아래 섹션에 설명되어 있습니다.

#

함수에서 에러가 발생하면 프로그램의 흐름이 변경되므로 코드에서 에러가 발생할 수 있는 위치를 빠르게 식별할 수 있는 것이 중요합니다.

코드에서 이러한 위치를 식별하려면 에러를 발생시킬 수 있는 함수, 메서드 또는 초기화 구문을 호출하는 코드 조각 앞에 `try` 또는 `try?` 또는 `try!` 키워드를 작성합니다.

이러한 키워드는 아래 섹션에 설명되어 있습니다.

> Note    
> Swift 의 에러 처리는 `try`, `catch` 그리고 `throw` 키워드를 사용하는 다른 언어의 에러 처리와 유사합니다.
> Objective-C 를 포함한 많은 언어의 에러 처리와 달리 Swift 의 에러 처리에는 계산 비용이 많이 들 수 있는 프로세스인 호출 스택 해제가 포함되지 않습니다.
> 따라서 `throw` 문의 성능 특성은 `return` 문의 성능 특성과 비슷합니다.

<br>

### Throwing 함수를 이용한 에러 전파 (Propagating Errors Using Throwing Functions)

함수, 메서드 또는 초기화가 에러를 던질 수 있음을 나타내려면 함수의 선언에서 파라미터 뒤에 `throws` 키워드를 작성합니다.

`throws` 로 표시된 함수는 throw 함수 라고 합니다.

함수가 반환 타입을 지정하는 경우 반환 화살표 (`->`) 앞에 `throws` 키워드를 작성합니다.

~~~ swift
func canThrowErrors() throws -> String

func cannotThrowErrors() -> String
~~~

throw 함수는 함수 내부에서 발생한 에러를 호출된 범위로 전파합니다.

> Note    
> throw 함수만 에러를 전파할 수 있습니다.
> throws 선언이 되지 않은 함수 내에서 발생한 모든 에러는 함수 내에서 처리되어야 합니다.

#

아래 예제에서 `VendingMachine` 클래스는 요청한 항목을 사용할 수 없거나 재고가 없거나 현재 예치된 금액을 초과하는 비용이 있는 경우 적절한 `VendingMachineError` 를 던지는 `vend(itemNamed:)` 메서드를 가지고 있습니다.

~~~ swift
struct Item {
    var price: Int
    var count: Int
}


class VendingMachine {
    var inventory = [
        "Candy Bar": Item(price: 12, count: 7),
        "Chips": Item(price: 10, count: 4),
        "Pretzels": Item(price: 7, count: 11)
    ]
    var coinsDeposited = 0

    func vend(itemNamed name: String) throws {
        guard let item = inventory[name] else {
            throw VendingMachineError.invalidSelection
        }

        guard item.count > 0 else {
            throw VendingMachineError.outOfStock
        }

        guard item.price <= coinsDeposited else {
            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)
        }

        coinsDeposited -= item.price

        var newItem = item
        newItem.count -= 1
        inventory[name] = newItem

        print("Dispensing \(name)")
    }
}
~~~

`vend(itemNamed:)` 메서드의 구현은 `guard` 문을 사용하여 메서드를 일찍 종료시키고 간식 구매 요구사항 중 하나라도 충족되지 않으면 적절한 에러를 발생시킵니다.

`throw` 문은 프로그램 제어를 즉시 전달하기 때문에 모든 요구사항이 충족되는 경우에만 항목이 판매됩니다.

#

`vend(itemNamed:)` 메서드는 발생하는 모든 에러를 전파하기 때문에 이 메서드를 호출하는 코드는 `do-catch` 문, `try?` 또는 `try!` 를 사용하여 에러를 처리하거나 계속해서 전파해야 합니다.

예를 들어 아래 예제의 `buyFavoriteSnack(person:vendingMachine:)` 은 throw 함수이며 `vend(itemNamed:)` 메서드에서 발생한 모든 에러는 `buyFavoriteSnack(person:vendingMachine:)` 함수가 호출되는 지점까지 전파됩니다.

~~~ swift
let favoriteSnacks = [
    "Alice": "Chips",
    "Bob": "Licorice",
    "Eve": "Pretzels",
]
func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? "Candy Bar"
    try vendingMachine.vend(itemNamed: snackName)
}
~~~

이 에제에서 `buyFavoriteSnack(person:vendingMachine:)` 함수는 주어진 사람의 좋아하는 간식을 찾고 `vending(itemNamed:)` 메서드를 호출하여 구매하려고 합니다.

`vend(itemNamed:)` 메서드는 에러를 발생시킬 수 있으므로 앞에 `try` 키워드를 붙여 호출합니다.

#

throw 초기화는 throw 함수와 같은 방법으로 에러를 전파할 수 있습니다.

예를 들어 아래 `PurchasedSnack` 구조체에 대한 초기화는 초기화 프로세스의 일부분으로 throw 함수를 호출하고 발생한 에러를 호출자에게 전파하여 처리합니다.

~~~ swift
struct PurchasedSnack {
    let name: String
    init(name: String, vendingMachine: VendingMachine) throws {
        try vendingMachine.vend(itemNamed: name)
        self.name = name
    }
}
~~~

<br>

### Do-Catch 를 사용하여 에러 처리 (Handling Errors Using Do-Catch)




























***

### ⬅️ [Optional Chaining](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/16.Optional%20Chaining.md)

### ➡️ [Concurrency](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/18.Concurrency.md)
