# Concurrency (동시성)

비동기 작업을 수행합니다.

Swift 는 구조화된 방식으로 비동기와 병렬 코드 작성을 위한 기본 제공 지원 기능을 제공합니다.

비동기 코드는 일시적으로 중단되었다가 다시 실행할 수 있지만 한번에 프로그램의 한부분만 실행됩니다.

프로그램에서 코드를 일시 중단하고 다시 실행하게 만들어주는데 이것은 UI 업데이트와 같이 짧은 작업을 계속 진행하면서 네트워크를 통해 데이터를 가져오거나 파일을 파싱(분석)하는 것과 같은 긴 실행 작업을 계속할 수 있습니다.

병렬 코드는 동시에 코드의 여러 부분이 실행됨을 의미합니다.

예를 들어 4코어 프로세서의 컴퓨터는 각 코어가 하나의 작업을 수행하므로 코드의 4개 부분을 동시에 실행할 수 있습니다.

병렬과 비동기 코드를 사용하는 프로그램은 한 번에 여러 작업을 수행하고 외부 시스템을 기다리는 작업을 중단 시킬 수 있습니다.

#

병렬 또는 비동기 코드의 추가적인 스케줄링 유연성에는 복잡성이 증가하는 비용도 수반됩니다.

Swift 를 사용하면 일부 컴파일 타임 검사를 하는 방식으로 당신의 코드 의도를 표현할 수 있습니다.

예를 들어 액터를 사용하여 변경가능한 상태에 안전하게 접근할 수 있습니다.

그러나 느리거나 버그가 있는 코드에 동시성을 추가한다고 해서 코드가 빠르거나 올바르게 동작한다는 보장은 없습니다.

사실 동시성을 추가하면 코드를 디버그하기 더 어렵게 만들 수도 있습니다.

그러나 동시성이 필요한 코드에서 Swift 의 언어 수준 동시성 지원을 사용하면 Swift 가 컴파일 타임에 문제를 찾는데 도움이 될 수 있습니다.

#

이 챕터의 나머지 부분에서는 동시성이라는 용어를 사용하여 비동기와 병렬 코드의 일반적인 조합을 나타냅니다.

> Note    
> 이전에 동시성 코드를 작성한 적이 있다면 쓰레드 동작에 익숙할 것입니다.
> Swift 의 동시성 모델은 쓰레드의 최상단에 구축되지만 쓰레드와 직접 상호작용하지 않습니다.
> Swift 의 비동기 함수는 실행중인 쓰레드를 포기할 수 있습니다.
> 그러면 첫번째 함수가 차단된 동안 해당 쓰레드에서 다른 비동기 함수가 실행될 수 있습니다.
> 비동기 함수의 실행이 재개될 때 Swift 는 해당 함수가 어떤 쓰레드에서 실행될지 보장하지 않습니다.

#

Swift 의 언어 지원을 사용하지 않고 동시성 코드를 작성할 수 있지만 해당 코드는 읽기가 더 어려운 경향이 있습니다.

예를 들어 다음 코드는 사진 이름 목록을 다운로드하고 해당 목록의 첫번째 사진을 다운로드한 후 해당 사진을 사용자에게 표시합니다.

~~~ swift
listPhotos(inGallery: "Summer Vacation") { photoNames in
    let sortedNames = photoNames.sorted()
    let name = sortedNames[0]
    downloadPhoto(named: name) { photo in
        show(photo)
    }
}
~~~

이 간단한 경우에도 완료 핸들러가 연속해서 작성되어야 하므로 결국 중첩된 클로저를 작성하게 됩니다.

이 스타일에서 더 많이 중첩된 복잡한 코드는 빠르게 다루기 어려울 수 있습니다.

<br>

## 비동기 함수 정의 및 호출 (Defining and Calling Asynchronous Functions)

비동기 함수 또는 비동기 메서드는 실행 도중에 일시적으로 중단될 수 있는 특수한 종류의 함수 또는 메서드 입니다.

이것은 완료될 때까지 실행되거나 에러가 발생하거나 또는 반환되지 않는 일반적인 동기 함수 및 메서드와 대조됩니다.

비동기 함수 또는 메서드는 이 세가지 중 하나를 수행하지만 무언가를 기다리고 있을 때 중간에 일시 중지될 수도 있습니다.

비동기 함수 또는 메서드의 본문 내부에서 실행을 일시 중지할 수 있는 부분을 표시합니다.

#

함수 또는 메서드가 비동기 임을 나타내려면 파라미터 뒤의 선언에 `async` 키워드를 작성합니다.

이것은 던지는 함수를 나타내기 위해 `throws` 키워드를 사용하는 것과 유사합니다.

함수 또는 메서드가 값을 반환하는 경우 반환 화살표 (`->`) 전에 `async` 를 작성합니다.

예를 들어 갤러리에서 사진의 이름을 가져오는 방법은 아래와 같습니다.

~~~ swift
func listPhotos(inGallery name: String) async -> [String] {
    let result = // ... some asynchronous networking code ...
    return result
}
~~~

비동기적이면서 던지기 기능을 하는 함수 또는 메서드의 경우 `throws` 앞에 `async` 를 작성합니다.

#

비동기 메서드를 호출할 때 해당 메서드가 반환될 때까지 실행이 일시 중단됩니다.

중단될 가능성이 있는 지점을 표시하기 위해 호출 앞에 `await` 을 작성합니다.

이것은 던지는 함수를 호출할 때 에러가 발생할 경우 프로그램의 흐름을 변경 가능함을 나타내기 위해 `try` 를 작성하는 것과 같습니다.

비동기 메서드 내부에서 실행 흐름은 다른 비동기 메서드를 호출할 때만 중단됩니다.

중단은 암시적이거나 선점적이지 않습니다.

즉 모든 가능한 모든 중단 지점이 `await` 로 표시됩니다.

코드에서 가능한 모든 중단 지점을 표시하면 동시성 코드를 더 쉽게 읽고 이해할 수 있습니다.

#

예를 들어 아래 코드는 갤러리에 있는 모든 사진의 이름을 가져온 다음 첫번째 사진을 표시합니다.

~~~ swift
let photoNames = await listPhotos(inGallery: "Summer Vacation")
let sortedNames = photoNames.sorted()
let name = sortedNames[0]
let photo = await downloadPhoto(named: name)
show(photo)
~~~

`listPhotos(inGallery:)` 와 `downloadPhoto(named:)` 함수 모두 네트워크 요청을 해야 하기 때문에 완료하는데 비교적 오랜시간이 걸릴 수 있습니다.

반환 화살표 전에 `async` 를 작성하여 둘 다 비동기로 만들면 이 코드는 사진이 준비될 때까지 기다리는 동안 앱의 나머지 코드는 계속 실행될 수 있습니다.

#

위 예제의 동시성을 이해하기 위한 실행 순서는 다음과 같습니다.

1. 코드는 첫번째 줄에서 실행을 시작하고 첫번째 `await` 까지 실행됩니다. `listPhotos(inGallery:)` 함수를 호출하고 해당 함수가 반환될 때까지 실행을 일시 중단합니다.

2. 이 코드의 실행이 중단되는 동안 같은 프로그램의 다른 동시 코드가 실행됩니다. 예를 들어 오랜시간 동안 실행되는 백그라운드 작업이 새로운 사진의 리스트를 계속 업데이트 할 수 있습니다. 이 코드는 `await` 으로 표시된 다음 중단 지점 또는 완료될 때까지 실행됩니다.

3. `listPhotos(inGallery:)` 가 반환된 후 이 코드는 해당 지점에서 시작하여 실행을 계속합니다. 반환된 값을 `photoNames` 에 할당합니다.

4. `sortedNames` 와 `name` 을 정의하는 라인은 일반적인 동기 코드 입니다. 이 라인은 `await` 으로 표시되지 않았으므로 가능한 중단 지점이 없습니다.

5. 다음 `await` 은 `downloadPhoto(named:)` 함수에 대한 호출을 표시합니다. 이 코드는 해당 함수가 반환될 때까지 실행을 다시 일시 중단하여 다른 동시 코드가 실행될 수 있는 기회를 제공합니다.

6. `downloadPhoto(named:)` 가 반환된 후에 반환값은 `photo` 에 할당된 다음 `show(_:)` 를 호출할 때 인수로 전달됩니다.

#

코드에서 `await` 으로 표시된 코드의 중단이 가능한 지점은 비동기 함수 또는 메서드가 반환될 때까지 기다리는 동안 현재 코드 부분이 실행을 일시적으로 중단할 수 있음을 나타냅니다.

이것을 쓰레드 양보 라고도 하는데 Swift 가 내부적으로 현재 쓰레드에서 코드 실행을 일시 중지하고 대신 해당 쓰레드에서 다른 코드를 실행하기 때문입니다.

`await` 으로 표시된 코드는 실행을 일시 중단할 수 있어야 하므로 프로그램의 특정 위치에서만 비동기 함수 또는 메서드를 호출할 수 있습니다.

- 비동기 함수, 메서드 또는 프로퍼티의 본문에 있는 코드

- `@main` 으로 표시된 구조체, 클래스 또는 열거형의 정적 (static) `main()` 메서드에 있는 코드

- 아래의 [구조화되지 않은 동시성 (Unstructured Concurrency)]() 에서 볼 수 있듯이 구조화되지 않은 하위 작업의 코드

#

`Task.yield()` 메서드를 호출하여 명시적으로 중단 지점을 삽입할 수 있습니다.

~~~ swift
func generateSlideshow(forGallery gallery: String) async {
    let photos = await listPhotos(inGallery: gallery)
    for photo in photos {
        // ... render a few seconds of video for this photo ...
        await Task.yield()
    }
}
~~~

영상 렌더링을 동기화하는 코드가 있다고 가정해보면 이것은 어떠한 중단 지점을 포함하지 않습니다.

영상 렌더링 작업은 오랜 시간이 걸릴 수 있습니다.

그러나 주기적으로 `Task.yield()` 를 호출하여 명시적으로 중단 지점을 삽입할 수 있습니다.

이러한 방법으로 오래걸리는 실행 코드를 구조화하면 Swift 는 이 작업과 다른 작업의 진행을 균형적으로 맞출 수 있습니다.

#

`Task.sleep(for:tolerance:clock:)` 메서드는 동시성이 어떻게 동작하는지 알기위해 간단한 코드를 작성할 때 유용합니다.

이 메서드는 주어진 시간만큼 현재 작업을 중단합니다.

다음은 네트워크 작업을 기다리는 것을 시뮬레이션하는데 사용되는 `sleep(for:tolerance:clock:)` 을 사용하는 `listPhotos(inGallery:)` 함수 입니다.

~~~ swift
func listPhotos(inGallery name: String) async throws -> [String] {
    try await Task.sleep(for: .seconds(2))
    return ["IMG001", "IMG99", "IMG0404"]
}
~~~

위 코드에서 `listPhotos(inGallery:)` 는 `Task.sleep(until:tolerance:clock:)` 호출이 에러를 발생시킬 수 있기 때문에 비동기와 던지기를 모두 작성하였습니다.

이 버전의 `listPhotos(inGallery:)` 를 호출하려면 `try` 와 `await` 모두 작성해야 합니다.

~~~ swift
let photos = try await listPhotos(inGallery: "A Rainy Weekend")
~~~

비동기 함수는 던지기 함수와 몇가지 유사한 점이 있습니다.

비동기 또는 던지는 함수를 정의할 때 `async` 또는 `throws` 를 표시하고 해당 함수를 호출할 때 `await` 또는 `try` 를 표시합니다.

비동기 함수는 던지는 함수가 다른 던지는 함수를 호출할 수 있는 것처럼 다른 비동기 함수를 호출할 수 있습니다.

#

하지만 매우 중요한 차이점이 있습니다.

에러를 처리하기 위해 `do-catch` 블럭에 코드를 래핑하거나 에러를 다른곳에서 처리하기 위해 에러를 저장하는 `Result` 를 사용할 수 있습니다.

이러한 접근방식은 던지지 않는 코드에서 던지는 함수를 호출할 수 있습니다.

~~~ swift
func availableRainyWeekendPhotos() -> Result<[String], Error> {
    return Result {
        try listDownloadedPhotos(inGallery: "A Rainy Weekend")
    }
}
~~~

반면 비동기 코드를 래핑하여 동기 코드에서 호출하고 결과를 기다릴 수 있는 안전한 방법은 없습니다.

Swift 표준 라이브러리는 의도적으로 이 안전하지 않은 기능을 생략합니다.

이를 직접 구현하려고 하면 미묘한 경합, 쓰레드 이슈 그리고 데드락과 같은 문제가 발생할 수 있습니다.

기존 프로젝트에 비동기 코드를 추가할 때는 위에서 아래로 작업해야 합니다.

특히 최상위 레이어부터 변환하여 비동기를 사용하도록 한 다음 호출하는 함수와 메서드를 변환하여 한번에 하나의 레이어씩 작업합니다.

동기 코드는 비동기 코드를 호출할 수 없으므로 상향식 접근 방식을 사용할 수 없습니다.

<br>

## 비동기 시퀀스 (Asynchronous Sequences)

이전 섹션에서 `listPhotos(inGallery:)` 함수는 배열의 모든 요소가 준비된 후에 전체 배열을 한번에 비동기적으로 반환합니다.

또 다른 접근 방식은 비동기 시퀀스를 사용하여 한번에 컬렉션의 한 요소를 기다리는 것입니다.

비동기 시퀀스에 대한 반복문 동작은 다음과 같습니다.

~~~ swift
import Foundation

let handle = FileHandle.standardInput
for try await line in handle.bytes.lines {
    print(line)
}
~~~

일반적인 `for-in` 루프를 사용하는 대신 위의 예제에서는 `for` 다음에 `await` 을 작성합니다.

비동기 함수 또는 메서드를 호출할 때와 마찬가지로 `await` 작성은 가능한 중단 지점을 나타냅니다.

`for - await - in` 루프는 다음 요소가 사용 가능할 때까지 기다리고 각 반복이 시작될 때 잠재적으로 실행을 일시 중단합니다.

#

[Sequence]() 프로토콜을 채택하여 `for-in` 반복문 루프에서 자체 타입을 사용할 수 있는 것과 같은 방식으로 [AsyncSequence]() 프로토콜을 채택하여 `for - await - in` 반복문 루프에서 자체 타입을 사용할 수 있습니다.

<br>

## 비동기 함수 병렬로 호출 (Calling Asynchronous Functions in Parallel)





















***

### ⬅️ [Error Handling](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/17.Error%20Handling.md)

### ➡️ [Macros](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/19.Macros.md)
