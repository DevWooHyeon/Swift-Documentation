# Swift 둘러보기 (A Swift Tour)

Swift 의 기능과 구문을 살펴봅니다.

전통적으로 새로운 언어의 첫번째 프로그램은 "Hello, world!" 를 출려해야 한다고 합니다.

Swift 에서는 이 작업을 한줄로 수행할 수 있습니다.

~~~ swift
print("Hello, world!")
// Prints "Hello, world!"
~~~

다른 언어를 알고 있다면 이 구문이 익숙해 보일 것입니다.

Swift 에서 이 코드의 라인은 완벽한 프로그램입니다. 텍스트 출력이나 문자열 처리와 같은 기능을 위해 별도의 라이브러리를 가져올 필요가 없습니다.

전역 범위에서 작성된 코드는 프로그램의 전체에서 사용되기 때문에 `main()` 함수가 필요하지 않습니다.

또한 모든 명령문 끝에 세미콜론을 작성할 필요도 없습니다.

#

이 둘러보기는 다양한 프로그래밍 작업을 수행하는 방법을 보여줌으로써 Swift 에서 코드 작성을 시작할 수 있는 충분한 정보를 제공합니다.

이해하지 못하는 부분이 있어도 걱정하지 마세요.

이 둘러보기에서 소개된 모든 내용은 이 문서의 나머지 부분에 자세히 설명되어 있습니다.

<br>

## 단순한 값 (Simple Value)

상수를 만들기 위해 `let` 을 사용하고 변수를 만들기 위해 `var` 를 사용합니다.

상수의 값은 컴파일 타임에 알 필요는 없지만 값을 반드시 한번은 할당 해야 합니다. 

이는 값은 한번만 할당되지만 여러 위치에서 사용할 수 있다는 의미입니다.

~~~ swift
var myVariable = 42
myVariable = 50
let myConstant = 42
~~~

상수 또는 변수는 할당하려는 값과 동일한 타입이어야 합니다.

그러나 항상 타입을 명시적으로 작성할 필요는 없습니다.

상수 또는 변수를 생성할 때 값을 제공하면 컴파일러가 해당 타입을 추론할 수 있습니다.

위의 예제에서 `myVariable` 의 초기값이 정수이기 때문에 컴파일러는 이를 정수로 추론합니다.

#

초기값이 충분한 정보를 제공하지 않거나 초기값이 없는 경우 변수 뒤에 콜론으로 구분하여 타입을 지정해야 합니다.

~~~ swift
let implicitInteger = 70
let implicitDouble = 70.0
let explicitDouble: Double = 70
~~~

> Experiment   
> 명시적 타입이 `Float` 이고 값이 `4` 인 상수를 만들어 봅시다.

#

값은 암시적으로는 다른 타입으로 절대 변환되지 않습니다.

값을 다른 타입으로 변환해야 하는 경우 원하는 타입의 인스턴스를 명시적으로 만들어야 합니다.

~~~ swift
let label = "The width is "
let width = 94
let widthLabel = label + String(width)
~~~

> Experiment   
> 마지막 줄에서 `String` 으로 변환하는 부분을 제거해 보세요. 어떤 에러가 발생합니까?

#

문자열에 값을 포함하는 더 간단한 방법이 있습니다.

소괄호 안에 값을 작성하고 소괄호 앞에 백슬래시 (\) 를 작성하면 됩니다. 

~~~ swift
let apples = 3
let oranges = 5
let appleSummary = "I have \(apples) apples."
let fruitSummary = "I have \(apples + oranges) pieces of fruit."
~~~

> Experiment   
> `\()` 를 사용하여 문자열에 부동 소수점 (floating-point) 계산을 포함하고 인사말에 누군가의 이름을 포함해 보십시오.

#

여러줄을 차지하는 문자열에는 3개의 쌍따옴표 (""") 를 사용합니다.

닫는 따옴표의 들여쓰기와 일치하는 한 각 인용된 줄의 시작부분에 있는 들여쓰기는 제거됩니다.

~~~ swift
let quotation = """
        Even though there's whitespace to the left,
        the actual lines aren't indented.
            Except for this line.
        Double quotes (") can appear without being escaped.

        I still have \(apples + oranges) pieces of fruit.
        """
~~~

#

대괄호 ([]) 를 사용하여 배열 (array) 과 딕셔너리 (dictionary) 를 생성하고 대괄호에 인덱스 또는 키를 작성하여 해당 요소에 접근할 수 있습니다.

마지막 요소 뒤에는 쉬표가 허용됩니다.

~~~ swift
var fruits = ["strawberries", "limes", "tangerines"]
fruits[1] = "grapes"


var occupations = [
    "Malcolm": "Captain",
    "Kaylee": "Mechanic",
 ]
occupations["Jayne"] = "Public Relations"
~~~

#

배열은 요소를 추가함에 따라 자동으로 크기가 늘어납니다.

~~~ swift
fruits.append("blueberries")
print(fruits)
// Prints "["strawberries", "grapes", "tangerines", "blueberries"]"
~~~

#

또한 대괄호를 사용하여 빈 배열 또는 딕셔너리를 작성합니다.

배열의 경우 `[]`, 딕셔너리의 경우 `[:]` 로 작성합니다.

~~~ swift
fruits = []
occupations = [:]
~~~

#

새로운 변수 또는 다른 장소의 타입 정보가 없는 곳에 빈 배열 또는 빈 딕셔너리를 할당하려면 타입을 명시해야 합니다.

~~~ swift
let emptyArray: [String] = []
let emptyDictionary: [String: Float] = [:]
~~~

<br>

## 제어 흐름 (Control Flow)

조건문을 만들려면 `if` 와 `switch` 를 사용하고, 루프를 만들려면 `for-in`, `while`, 그리고 `repeat-while` 을 사용합니다.

조건문이나 루프의 변수를 둘러싼 소괄호는 선택사항 입니다. 본문을 둘러싼 중괄호는 필수사항 입니다.

~~~ swift
let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {
    if score > 50 {
        teamScore += 3
    } else {
        teamScore += 1
    }
}
print(teamScore)
// Prints "11"
~~~

if 문에서는 조건부가 반드시 부울 (Boolean) 로 표현되어야 합니다.

즉, `if score { ... }` 와 같은 코드는 암시적으로 0과 비교하는것이 아니라 에러를 의미합니다.

#

조건에 따라 값을 선택하기위해 할당의 `equal sign (=)` 뒤나 `return` 뒤에 `if` 또는 `switch` 를 작성할 수 있습니다.

~~~ swift
let scoreDecoration = if teamScore > 10 {
    "🎉"
} else {
    ""
}
print("Score:", teamScore, scoreDecoration)
// Prints "Score: 11 🎉"
~~~

#

`if` 와 `let` 을 사용하여 누락될 수 있는 값을 작업하기 위해 사용할 수 있습니다. 이러한 값은 옵셔널 (Optional) 로 표기됩니다.

옵셔널 값은 값을 포함하거나 값이 없음을 나타내는 `nil` 을 포함합니다.

값을 옵셔널로 표시하려면 값의 타입뒤에 물음표 (?) 를 작성합니다.

~~~ swift
var optionalString: String? = "Hello"
print(optionalString == nil)
// Prints "false"


var optionalName: String? = "John Appleseed"
var greeting = "Hello!"
if let name = optionalName {
    greeting = "Hello, \(name)"
}
~~~

> Experiment   
> `optionalName` 을 `nil` 로 변경하십시오. 어떤 인사말을 얻습니까?   
> `optionalName` 이 `nil` 인 경우 다른 인사말을 설정하기 위해 `else` 절을 추가하십시오.

#

옵셔널 값이 `nil` 이면 조건은 `false` 이고 중괄호 안에 코드는 건너뜁니다.

옵셔널 값이 `nil` 이 아니면 옵셔널 값은 언래핑되고 `let` 뒤의 상수로 할당 되어 코드 블럭 안에서 언래핑 된 값으로 사용할 수 있습니다.

#

옵셔널 값을 처리하는 다른 방법은 `??` 연산자를 사용하여 기본값을 제공하는 것입니다.

옵셔널 값이 없다면 기본값이 대신 사용됩니다.

~~~ swift
let nickname: String? = nil
let fullName: String = "John Appleseed"
let informalGreeting = "Hi \(nickname ?? fullName)"
~~~

#

언래핑된 값에 대해 동일한 이름을 사용하여 더 짧게 값을 언래핑할 수 있습니다.

~~~ swift
if let nickname {
    print("Hey, \(nickname)")
}
// Doesn't print anything, because nickname is nil.
~~~

#

스위치 (switch) 는 모든 종류의 데이터와 다양한 비교 작업을 지원합니다.

스위치는 정수 (integer) 및 동등성 비교로만 제한되지 않습니다.

~~~ swift
let vegetable = "red pepper"
switch vegetable {
case "celery":
    print("Add some raisins and make ants on a log.")
case "cucumber", "watercress":
    print("That would make a good tea sandwich.")
case let x where x.hasSuffix("pepper"):
    print("Is it a spicy \(x)?")
default:
    print("Everything tastes good in soup.")
}
// Prints "Is it a spicy red pepper?"
~~~

> Experiment
> default 케이스를 삭제해 봅시다. 어떤 에러가 발생합니까?


패턴과 일치하는 값을 상수에 할당하기 위해 패턴에서 `let` 을 어떻게 사용하는지 확인하세요.

일치하는 스위치 케이스 (case) 문을 실행하고 프로그램은 스위치 문을 종료합니다.

다음 케이스로 이어서 실행되지 않기 때문에 각 케이스 코드에 명시적으로 스위치 종료를 할 필요가 없습니다.

#

`for-in` 을 사용하면 각 키-값 쌍에 사용할 이름의 쌍을 제공하여 딕셔너리의 항목을 반복할 수 있습니다.

딕셔너리는 순서가 지정되지 않은 컬렉션 (collection) 이므로 해당 키와 값은 임의의 순서로 반복됩니다.

~~~ swift
let interestingNumbers = [
    "Prime": [2, 3, 5, 7, 11, 13],
    "Fibonacci": [1, 1, 2, 3, 5, 8],
    "Square": [1, 4, 9, 16, 25],
]
var largest = 0
for (_, numbers) in interestingNumbers {
    for number in numbers {
        if number > largest {
            largest = number
        }
    }
}
print(largest)
// Prints "25"
~~~

> Experiment
> `_` 를 변수의 이름으로 변경하고 어떤 숫자가 가장 큰지 추적하십시오.

#

조건이 변경될 때까지 코드 블럭을 반복하려면 `while` 을 사용해야 합니다.

또한 루프의 조건이 끝에 있을 수 있으므로 적어도 한번은 루프가 실행되도록 할 수 있습니다.

~~~ swift
var n = 2
while n < 100 {
    n *= 2
}
print(n)
// Prints "128"


var m = 2
repeat {
    m *= 2
} while m < 100
print(m)
// Prints "128"
~~~

> Experiment
> 루프 조건이 이미 참일 때 `while` 과 `repeat-while` 이 어떻게 다른지 살펴보기위해 `m < 100` 에서 `m < 0` 으로 조건을 변경해 봅시다.

#

인덱스의 범위를 만들기 위해선 `..<` 을 사용하여 루프에 인덱스를 만들 수 있습니다.

~~~ swift
var total = 0
for i in 0..<4 {
    total += i
}
print(total)
// Prints "6"
~~~

가장 상위 값을 생략하는 범위를 만들기 위해 `..<` 를 사용하고 두 값을 모두 포함하는 범위를 만들기 위해 `...` 을 사용합니다.

<br>

## 함수와 클로저 (Functions and Closures)

함수를 선언할때는 `func` 를 사용합니다. 소괄호 안에 인수의 리스트와 함수의 이름으로 호출합니다.

함수의 반환 타입 (return type) 은 파라미터 (parameter) 의 이름, 타입과 구분하기 위해 `->` 를 사용합니다.

~~~ swift
func greet(person: String, day: String) -> String {
    return "Hello \(person), today is \(day)."
}
greet(person: "Bob", day: "Tuesday")
~~~

> Experiment
> `day` 파라미터를 지워 봅시다. 인사말에 오늘의 점심 특선 요리를 포함하기 위해 파라미터를 추가해 봅시다.

#

기본적으로 함수는 파라미터 이름을 인수의 레이블로 사용합니다.

파라미터 이름 앞에 인수 레이블을 작성하거나 인수 레이블을 사용하지 않으려면 `_` 를 작성해야 합니다.

~~~ swift
func greet(_ person: String, on day: String) -> String {
    return "Hello \(person), today is \(day)."
}
greet("John", on: "Wednesday")
~~~

#

튜플 (tuple) 을 사용하여 복합 값을 만듭니다.

예를 들어 함수에서 여러 값을 반환할 때 사용합니다. 튜플의 요소는 이름 또는 번호로 참조할 수 있습니다.

~~~ swift
func calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) {
    var min = scores[0]
    var max = scores[0]
    var sum = 0


    for score in scores {
        if score > max {
            max = score
        } else if score < min {
            min = score
        }
        sum += score
    }


    return (min, max, sum)
}
let statistics = calculateStatistics(scores: [5, 3, 100, 3, 9])
print(statistics.sum)
// Prints "120"
print(statistics.2)
// Prints "120"
~~~

#

함수는 중첩될 수 있습니다.

중첩 함수는 외부 함수에서 선언된 변수에 접근할 수 있습니다.

중첩된 함수를 사용하여 길거나 복잡한 함수에서 코드를 구성할 수 있습니다.

~~~ swift
func returnFifteen() -> Int {
    var y = 10
    func add() {
        y += 5
    }
    add()
    return y
}
returnFifteen()
~~~

함수는 일급 타입 (first-class type) 입니다.

이것은 함수가 다른 함수를 값으로 반환할 수 있음을 의미합니다.

~~~ swift
func makeIncrementer() -> ((Int) -> Int) {
    func addOne(number: Int) -> Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)
~~~

#

함수는 다른 함수를 인수 (argument) 중 하나로 가질 수 있습니다.

~~~ swift
func hasAnyMatches(list: [Int], condition: (Int) -> Bool) -> Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -> Bool {
    return number < 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(list: numbers, condition: lessThanTen)
~~~

#

함수는 실제로 나중에 호출될 수 있는 코드 블럭인 클로저 (closure) 의 특별한 케이스 입니다.

클로저에 있는 코드는 이미 중첩된 함수의 예제에서 보았듯이 클로저가 실행될 때 다른 범위에 있더라도 클로저가 생성된 범위에서 사용 가능한 변수, 함수와 같은 항목에 접근할 수 있습니다.

중괄호 ({}) 로 묶어 이름없이 클로저를 작성할 수 있습니다.

본문으로부터 인수와 반환 타입을 분리하기 위해 `in` 을 사용합니다.

~~~ swift
numbers.map({ (number: Int) -> Int in
    let result = 3 * number
    return result
})
~~~

> Experiment
> 모든 홀수에 대해 0을 반환하도록 클로저를 다시 작성하십시오.

#

클로저를 더 간단하게 작성하기 위한 몇가지 선택사항이 있습니다.

대리자 (delegate) 에 대한 콜백과 같이 클로저의 타입을 이미 알고 있다면 파라미터의 타입, 반환 타입 또는 둘다 생략할 수 있습니다.

단일 명령문 클로저는 암시적으로 유일한 명령문의 값을 반환합니다.

~~~ swift
let mappedNumbers = numbers.map({ number in 3 * number })
print(mappedNumbers)
// Prints "[60, 57, 21, 36]"
~~~

#

매우 짧은 클로저에 유용한 접근 방식으로 이름 대신 숫자로 파라미터를 참조할 수 있습니다.

함수의 마지막 인자로 전달된 클로저는 소괄호 바로 뒤에 나타날 수 있습니다.

클로저가 함수의 유일한 인수인 경우 소괄호는 생략할 수 있습니다.

~~~ swift
let sortedNumbers = numbers.sorted { $0 > $1 }
print(sortedNumbers)
// Prints "[20, 19, 12, 7]"
~~~

<br>

## 객체와 클래스 (Objects and Classes)

`class` 뒤에 클래스 (class) 의 이름을 사용하여 클래스를 생성합니다.

클래스에서 프로퍼티 선언은 클래스의 컨텍스트 (context) 내에 있다는 점을 제외하면 상수 또는 변수 선언과 동일한 방식으로 작성됩니다.

마찬가지로 메서드와 함수 선언도 동일한 방식으로 작성됩니다.

~~~ swift
class Shape {
    var numberOfSides = 0
    func simpleDescription() -> String {
        return "A shape with \(numberOfSides) sides."
    }
}
~~~

> Experiment   
> `let` 을 사용하여 상수 프로퍼티를 추가하고 인수를 가지는 다른 메서드를 추가해 보시기 바랍니다.

#

클래스 이름 뒤에 소괄호를 넣어 클래스의 인스턴스를 생성합니다.

인스턴스의 프로퍼티와 메서드에 접근하기 위해 점 구문을 사용합니다.

~~~ swift
var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
~~~

#

이 버전의 `shape` 클래스는 인스턴스가 생성될 때 클래스를 설정하는 초기화 구문 (initializer) 이 생략되었습니다.

`init` 을 사용하여 생성합니다.

~~~ swift
class NamedShape {
    var numberOfSides: Int = 0
    var name: String


    init(name: String) {
       self.name = name
    }


    func simpleDescription() -> String {
       return "A shape with \(numberOfSides) sides."
    }
}
~~~

#

초기화 구문에서 `name` 인수와 `name` 프로퍼티를 구분하기 위해 `self` 가 어떻게 사용되는지 확인 하십시오.

초기화 구문의 인수는 클래스의 인스턴스를 생성할 때 함수 호출처럼 전달됩니다.

모든 프로퍼티는 `numberOfSides` 와 같이 선언 시나 `name` 과 같이 초기화 구문에서 값을 할당해야 합니다.

#

객체가 할당 해제되기 전에 일부 정리작업이 필요하여 초기화 해제 구문 (deinitializer) 을 생성하려면 `deinit` 을 사용합니다.

#

하위 클래스 (subclass) 는 클래스 이름 뒤에 콜론으로 구분하여 상위 클래스 (superclass) 이름이 포함됩니다.

클래스가 모든 표준 루트 클래스를 하위 클래스화 할 필요 없으므로 필요에 따라 상위 클래스를 포함하거나 생략할 수 있습니다.

#

상위 클래스의 구현을 재정의 하는 하위 클래스의 메서드는 `override` 로 표시됩니다.

실수로 `override` 없이 메서드를 재정의 하면 에러로 컴파일러에 의해 감지됩니다.

컴파일러는 실제로 슈퍼 클래스의 어떤 메서드도 재정의 하지 않았는데도 `override` 키워드를 사용하는 메서드를 감지합니다.

~~~ swift
class Square: NamedShape {
    var sideLength: Double


    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 4
    }


    func area() -> Double {
        return sideLength * sideLength
    }


    override func simpleDescription() -> String {
        return "A square with sides of length \(sideLength)."
    }
}
let test = Square(sideLength: 5.2, name: "my test square")
test.area()
test.simpleDescription()
~~~

> Experiment    
> 초기화 구문에 반지름과 이름을 인수로 가지는 `Circle` 이라는 `NamedShape` 의 하위 클래스를 만들어 보세요.     
> `Circle` 클래스에 `area()` 와 `simpleDescription()` 메서드를 구현해 보세요.

#

저장된 단순 프로퍼티 외에도 프로퍼티는 getter 와 setter 를 가질 수 있습니다.

~~~ swift
class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0


    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
    }


    var perimeter: Double {
        get {
             return 3.0 * sideLength
        }
        set {
            sideLength = newValue / 3.0
        }
    }


    override func simpleDescription() -> String {
        return "An equilateral triangle with sides of length \(sideLength)."
    }
}
var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle")
print(triangle.perimeter)
// Prints "9.3"
triangle.perimeter = 9.9
print(triangle.sideLength)
// Prints "3.3000000000000003"
~~~

`perimeter` 의 setter 에서 새로운 값은 암시적으로 `newValue` 라는 이름을 가집니다.

`set` 이후에 소괄호 안에 명시적으로 이름을 제공할 수 있습니다.

`EquilateralTriangle` 클래스의 초기화 구문은 세가지 단계가 있습니다.

1. 하위 클래스가 선언한 프로퍼티의 값을 설정합니다.
2. 상위 클래스의 초기화 구문을 호출합니다.
3. 상위 클래스에 의해 정의된 프로퍼티의 값을 변경합니다. 메서드, getter, setter 를 사용하는 추가 작업도 이 시점에서 수행할 수 있습니다.

#

프로퍼티를 계산할 필요는 없지만 새로운 값을 설정하기 전과 후에 실행되는 코드를 제공하려면 `willSet` 과 `didSet` 을 사용하면 됩니다.

이렇게 제공한 코드는 초기화 구문의 외부에서 값이 변경될 때마다 실행됩니다.

예를 들어 아래의 클래스는 삼각형의 변 길이가 항상 정사각형의 변 길이와 같다는 것을 확인합니다.

~~~ swift
class TriangleAndSquare {
    var triangle: EquilateralTriangle {
        willSet {
            square.sideLength = newValue.sideLength
        }
    }
    var square: Square {
        willSet {
            triangle.sideLength = newValue.sideLength
        }
    }
    init(size: Double, name: String) {
        square = Square(sideLength: size, name: name)
        triangle = EquilateralTriangle(sideLength: size, name: name)
    }
}
var triangleAndSquare = TriangleAndSquare(size: 10, name: "another test shape")
print(triangleAndSquare.square.sideLength)
// Prints "10.0"
print(triangleAndSquare.triangle.sideLength)
// Prints "10.0"
triangleAndSquare.square = Square(sideLength: 50, name: "larger square")
print(triangleAndSquare.triangle.sideLength)
// Prints "50.0"
~~~

#

옵셔널 값으로 동작할 때 메서드, 프로퍼티, 서브 스크립트 (subscript) 와 같은 작업 이전에 `?` 를 작성할 수 있습니다.

`?` 전의 값이 `nil` 이면 `?` 이후의 모든 값은 무시되고 전체 표현식의 값은 `nil` 입니다.

그렇지 않으면 옵셔널 값은 언래핑 되고 `?` 이후의 모든 항목은 언래핑된 값에 따라 작동합니다.

두가지 경우 모두 전체 표현식의 값은 옵셔널 값입니다.

~~~ swift
let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square")
let sideLength = optionalSquare?.sideLength
~~~

<br>

## 열거형과 구조체 (Enumerations and Structures)

열거형을 생성하기 위해 `enum` 을 사용합니다.

클래스 및 기타 모든 명명된 타입과 마찬가지로 열거형은 연관된 메서를 가질 수 있습니다.

~~~ swift
enum Rank: Int {
    case ace = 1
    case two, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king


    func simpleDescription() -> String {
        switch self {
        case .ace:
            return "ace"
        case .jack:
            return "jack"
        case .queen:
            return "queen"
        case .king:
            return "king"
        default:
            return String(self.rawValue)
        }
    }
}
let ace = Rank.ace
let aceRawValue = ace.rawValue
~~~

> Experiment
> 원시값으로 2개의 `Rank` 값을 비교하는 함수를 작성해 보세요.

#












***

### ⬅️ [Version Compatibility](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/1.Welcome%20to%20Swift/2.Version%20Compatibility.md)

### ➡️ [The Basics](https://github.com/Developer-Nova/Swift-Documentation/blob/main/Swift%20Documentation/2.Language%20Guide/1.The%20Basics.md)
